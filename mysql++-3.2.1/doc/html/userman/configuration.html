<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>8. Configuring MySQL++</title><link rel="stylesheet" href="tangentsoft.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.69.1"><link rel="start" href="index.html" title="MySQL++ v3.2.1 User Manual"><link rel="up" href="index.html" title="MySQL++ v3.2.1 User Manual"><link rel="prev" href="threads.html" title="7. Using MySQL++ in a Multithreaded Program"><link rel="next" href="incorporating.html" title="9. Using MySQL++ in Your Own Project"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">8. Configuring MySQL++</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="threads.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="incorporating.html">Next</a></td></tr></table><hr></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration"></a>8. Configuring MySQL++</h2></div></div></div><p>The default configuration of MySQL++ is suitable for most
  purposes, but there are a few things you can change to make it meet
  special needs.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mysql-loc"></a>8.1. The Location of the MySQL Development Files</h3></div></div></div><p>MySQL++ is built on top
    of the MySQL C API. (Now called <a href="https://dev.mysql.com/downloads/connector/c/" target="_top">Connector/C</a>.)
    MySQL++ relies on this low-level library for all communication
    with the database server. Consequently, the build process for
    MySQL++ may fail if it can&#8217;t find the C API headers and
    library.</p><p>On platforms that use Autoconf<sup>[<a name="idp5683696" href="#ftn.idp5683696">19</a>]</sup>, the <code class="filename">configure</code>
    script can usually figure out the location of the C API
    development files by itself<sup>[<a name="idp6344720" href="#ftn.idp6344720">20</a>]</sup> It simply
    tries a bunch of common installation locations until it finds one
    that works. If your MySQL server was installed in a nonstandard
    location, you will have to tell the <code class="filename">configure</code>
    script where these files are with some combination
    of the <code class="computeroutput">--with-mysql</code>,
    <code class="computeroutput">--with-mysql-include</code>, and
    <code class="computeroutput">--with-mysql-lib</code> flags. See
    <code class="filename">README-Unix.txt</code> for details.</p><p>No other platform allows this sort of auto-discovery, so
    the build files for these platforms simply hard-code the default
    installation location for the current GA version of Connector/C
    at the time that version of MySQL++ was released. For example,
    the Visual C++ project files currently assume MySQL is in
    <code class="filename">c:\Program Files\MySQL\MySQL Server 5.1</code>. If
    you&#8217;re using some other release of MySQL or you installed it
    somewhere else, you will have to modify the build files.  How you
    do this, exactly, varies based on platform and what tools you
    have on hand. See <code class="filename">README-Visual-C++.txt</code>,
    <code class="filename">README-MinGW.txt</code>, or
    <code class="filename">README-Mac-OS-X.txt</code>, as appropriate.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="max-fields"></a>8.2. The Maximum Number of Fields Allowed</h3></div></div></div><p>MySQL++ offers two ways to automatically build SQL
    queries at run time: <a href="tquery.html">Template Queries</a> and <a href="ssqls.html" title="5. Specialized SQL Structures">SSQLS</a>. There&#8217;s a limit on the number
    of fields these mechanisms support, defaulting to 25 fields in the
    official MySQL++ packages.<sup>[<a name="idp5561088" href="#ftn.idp5561088">21</a>]</sup> The files
    embodying these limits are <code class="filename">lib/querydef.h</code> and
    <code class="filename">lib/ssqls.h</code>, each generated by Perl scripts of
    the same name but with a <code class="filename">.pl</code> extension.</p><p>The default <code class="filename">querydef.h</code> is small and
    its size only increases linearly with respect to maximum field
    count.</p><p><code class="filename">ssqls.h</code> is a totally
    different story. The default 25 field limit
    makes <code class="filename">ssqls.pl</code> generate an
    <code class="filename">ssqls.h</code> over 1 MB. Worse,
    the field limit to file size relation is
    <span class="emphasis"><em>quadratic</em></span>.<sup>[<a name="idp9879264" href="#ftn.idp9879264">22</a>]</sup>
    This has a number of bad effects:</p><div class="itemizedlist"><ul type="disc"><li><p>Generating header files to support more fields than
        you actually require is a waste of space and bandwidth.</p></li><li><p>Some compilers have arbitrary limits on the size of
        macros they&#8217;re able to parse. Exceeding these limits
        usually causes the compiler to misbehave badly, rather than
        fail gracefully.</p></li><li><p>Because it increases the size of two key files used
        in building MySQL++ itself and programs built on it, it
        increases compile times significantly. One test I did here
        showed a tripling of compile time from quadrupling the field
        limit.</p></li><li><p>More than 25 fields in a table is a good sign of a bad
        database design, most likely a denormalization problem.</p></li></ul></div><p>The default limits try to mitigate against all of these
    factors while still being high enough to be useful with most
    DB designs.</p><p>If you&#8217;re building MySQL++ from source on a platform
    that uses Autoconf, the easiest way to change these limits is at
    configuration time:</p><pre class="screen">
./configure --with-field-limit=50</pre><p>That causes the configuration script to pass the
    <span><strong class="command">-f</strong></span> flag to the two Perl scripts named above,
    overriding the default of 25 fields. Obviously you need a
    Perl interpreter on the system for this to work, but Perl is
    usually installed by default on systems MySQL++ supports via
    Autoconf.</p><p>On all other platforms, you&#8217;ll have to give the
    <span><strong class="command">-f</strong></span> flag to these scripts yourself. This
    may require installing Perl and putting it in the command
    path first. Having done that, you can do something like this to
    raise the limits:</p><pre class="screen">
cd lib
perl ssqls.pl -f 50
perl querydef.pl -f 50</pre><p>Note the need to run these commands within the
    <code class="filename">lib</code> subdirectory of the MySQL++ source
    tree. (This is done for you automatically on systems where you
    are able to use the Autoconf method.)</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="buried-headers"></a>8.3. Buried MySQL C API Headers</h3></div></div></div><p>It&#8217;s common these days on Unixy systems to install
    the MySQL C API headers in a <code class="filename">mysql</code> directory
    under some common <code class="filename">include</code> directory. If the
    C API headers are in <code class="filename">/usr/include/mysql</code>, we
    say they are &#8220;buried&#8221; underneath the system&#8217;s
    main include directory, <code class="filename">/usr/include</code>. Since
    the MySQL++ headers depend on these C API headers, it can be
    useful for MySQL++ to know this fact.</p><p>When MySQL++ includes one of the C API headers, it normally
    does so in the obvious way:</p><pre class="programlisting">
#include &lt;mysql.h&gt;
</pre><p>But, if you define the
    <code class="varname">MYSQLPP_MYSQL_HEADERS_BURIED</code> macro, it switches
    to this style:</p><pre class="programlisting">
#include &lt;mysql/mysql.h&gt;
</pre><p>In common situations like the
    <code class="filename">/usr/include/mysql</code> one, this simplifies the
    include path options you pass to your compiler.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="c99"></a>8.4. Building MySQL++ on Systems Without Complete C99
    Support</h3></div></div></div><p>MySQL++ uses the <a href="http://en.wikipedia.org/wiki/C_(programming_language)#C99" target="_top">C99</a>
    header <code class="filename">stdint.h</code> for portable fixed-size
    integer typedefs where possible. The C99 extensions aren&#8217;t
    yet officially part of the C++ Standard, so there are still
    some C++ compilers that don&#8217;t offer this header. MySQL++
    works around the lack of this header where it knows it needs
    to, but your platform might not be recognized, causing
    the build to break. If this happens, you can define the
    <code class="varname">MYSQLPP_NO_STDINT_H</code> macro to make MySQL++
    use its best guess for suitable integer types instead of relying
    on <code class="filename">stdint.h</code>.</p><p>MySQL++ also uses C99&#8217;s <span class="type">long long</span>
    data type where available. MySQL++ has workarounds for platforms
    where this is known not to be available, but if you get errors in
    <code class="filename">common.h</code> about this type, you can define the
    macro <code class="varname">MYSQLPP_NO_LONG_LONGS</code> to make MySQL++
    fall back to portable constructs.</p></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.idp5683696" href="#idp5683696">19</a>] </sup>Linux,
    Solaris, the BSDs, Mac OS X command line (as opposed to the
    Xcode IDE), Cygwin... Basically, Unix or anything that works
    like it.</p></div><div class="footnote"><p><sup>[<a name="ftn.idp6344720" href="#idp6344720">20</a>] </sup>I don&#8217;t say
    &#8220;Connector/C&#8221; here because the name change generally
    hasn&#8217;t percolated out to Unixy systems. It&#8217;s more
    commonly used on Windows systems, since the separate Connector/C
    download lets them avoid installing a MySQL server just to get
    development headers and libraries.</p></div><div class="footnote"><p><sup>[<a name="ftn.idp5561088" href="#idp5561088">21</a>] </sup>If you&#8217;re using
    a third-party MySQL++ package, its maintainer may have increased
    these field counts so the resulting headers more closely approach
    the size limit of the compiler the package was built with. In that
    case, you can look at the top of each generated header file to
    find out how many fields each supports.</p></div><div class="footnote"><p><sup>[<a name="ftn.idp9879264" href="#idp9879264">22</a>] </sup>The file
    size equation, for you amateur mathematicians out there,
    is <em class="phrase">N<sub>lines</sub> =
    18.5f<sup>2</sup> + 454.5f + 196.4</em>,
    where <code class="varname">f</code> is the field count.</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="threads.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="incorporating.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">7. Using MySQL++ in a Multithreaded Program </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 9. Using MySQL++ in Your Own Project</td></tr></table></div></body></html>
