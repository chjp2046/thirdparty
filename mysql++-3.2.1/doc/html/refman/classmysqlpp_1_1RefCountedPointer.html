<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
	<title>MySQL++ Reference Manual</title>
	<meta http-equiv="Content-type" content="text/html;charset=iso-8859-1">
	<link href="doxygen.css" rel="stylesheet" type="text/css">
	<link href="refman.css" rel="stylesheet" type="text/css">
</head>
<body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<b>mysqlpp</b>::<a class="el" href="classmysqlpp_1_1RefCountedPointer.html">RefCountedPointer</a></div>
<h1>mysqlpp::RefCountedPointer&lt; T, Destroyer &gt; Class Template Reference</h1><!-- doxytag: class="mysqlpp::RefCountedPointer" -->Creates an object that acts as a reference-counted pointer to another object.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="refcounted_8h-source.html">refcounted.h</a>&gt;</code>
<p>
Inheritance diagram for mysqlpp::RefCountedPointer&lt; T, Destroyer &gt;:<p><center><img src="classmysqlpp_1_1RefCountedPointer__inherit__graph.png" border="0" usemap="#mysqlpp_1_1RefCountedPointer_3_01T_00_01Destroyer_01_4__inherit__map" alt="Inheritance graph"></center>
<map name="mysqlpp_1_1RefCountedPointer_3_01T_00_01Destroyer_01_4__inherit__map">
<area href="classmysqlpp_1_1RefCountedPointer.html" shape="rect" coords="552,5,923,32" alt="">
<area href="classmysqlpp_1_1RefCountedPointer.html" shape="rect" coords="548,56,927,83" alt="">
<area href="classmysqlpp_1_1RefCountedPointer.html" shape="rect" coords="580,107,895,133" alt="">
</map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center>Collaboration diagram for mysqlpp::RefCountedPointer&lt; T, Destroyer &gt;:<p><center><img src="classmysqlpp_1_1RefCountedPointer__coll__graph.png" border="0" usemap="#mysqlpp_1_1RefCountedPointer_3_01T_00_01Destroyer_01_4__coll__map" alt="Collaboration graph"></center>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center><a href="classmysqlpp_1_1RefCountedPointer-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="745d3cf3d478d70c09474eb8766bae3a"></a><!-- doxytag: member="mysqlpp::RefCountedPointer::ThisType" ref="745d3cf3d478d70c09474eb8766bae3a" args="" -->
typedef <a class="el" href="classmysqlpp_1_1RefCountedPointer.html">RefCountedPointer</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1RefCountedPointer.html#745d3cf3d478d70c09474eb8766bae3a">ThisType</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">alias for this object's type <br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1RefCountedPointer.html#02aa2860b0644b6333cee8f321477fee">RefCountedPointer</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor.  <a href="#02aa2860b0644b6333cee8f321477fee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1RefCountedPointer.html#586313b144a88e487d77adf7d64bd3bb">RefCountedPointer</a> (T *c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Standard constructor.  <a href="#586313b144a88e487d77adf7d64bd3bb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e25ec10685c0c1ae2c7afa6bd72f483c"></a><!-- doxytag: member="mysqlpp::RefCountedPointer::RefCountedPointer" ref="e25ec10685c0c1ae2c7afa6bd72f483c" args="(const ThisType &amp;other)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1RefCountedPointer.html#e25ec10685c0c1ae2c7afa6bd72f483c">RefCountedPointer</a> (const <a class="el" href="classmysqlpp_1_1RefCountedPointer.html">ThisType</a> &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1RefCountedPointer.html#67b7d093310fa6112a45c361c37d5ed3">~RefCountedPointer</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#67b7d093310fa6112a45c361c37d5ed3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classmysqlpp_1_1RefCountedPointer.html">ThisType</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1RefCountedPointer.html#c6a54b0c4fdac3d05389639c5bc71168">assign</a> (T *c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets (or resets) the pointer to the counted object.  <a href="#c6a54b0c4fdac3d05389639c5bc71168"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classmysqlpp_1_1RefCountedPointer.html">ThisType</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1RefCountedPointer.html#a806e37d44b4d0384dc0bcd1deefd1b9">assign</a> (const <a class="el" href="classmysqlpp_1_1RefCountedPointer.html">ThisType</a> &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy an existing refcounted pointer.  <a href="#a806e37d44b4d0384dc0bcd1deefd1b9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classmysqlpp_1_1RefCountedPointer.html">ThisType</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1RefCountedPointer.html#33e254256ace5abc2b07d8a630e55188">operator=</a> (T *c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classmysqlpp_1_1Set.html">Set</a> (or reset) the pointer to the counted object.  <a href="#33e254256ace5abc2b07d8a630e55188"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classmysqlpp_1_1RefCountedPointer.html">ThisType</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1RefCountedPointer.html#506a85c3e871b5436eb20d6436fb5d9d">operator=</a> (const <a class="el" href="classmysqlpp_1_1RefCountedPointer.html">ThisType</a> &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy an existing refcounted pointer.  <a href="#506a85c3e871b5436eb20d6436fb5d9d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="02fc8a47004dad04067d7cb781e93dd7"></a><!-- doxytag: member="mysqlpp::RefCountedPointer::operator-&gt;" ref="02fc8a47004dad04067d7cb781e93dd7" args="() const " -->
T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1RefCountedPointer.html#02fc8a47004dad04067d7cb781e93dd7">operator-&gt;</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the object through the smart pointer. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f31d17f14e26b6605ff192d58ababea9"></a><!-- doxytag: member="mysqlpp::RefCountedPointer::operator *" ref="f31d17f14e26b6605ff192d58ababea9" args="() const " -->
T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1RefCountedPointer.html#f31d17f14e26b6605ff192d58ababea9">operator *</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dereference the smart pointer. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1RefCountedPointer.html#48f681f74dbe025e8c639f65850e2302">operator void *</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the internal raw pointer converted to void*.  <a href="#48f681f74dbe025e8c639f65850e2302"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1RefCountedPointer.html#067a0afe4a3f5ef1a6a68ddbcdced99a">operator const void *</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the internal raw pointer converted to const void*.  <a href="#067a0afe4a3f5ef1a6a68ddbcdced99a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="26757f1138dded33faeb1978004d0639"></a><!-- doxytag: member="mysqlpp::RefCountedPointer::raw" ref="26757f1138dded33faeb1978004d0639" args="()" -->
T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1RefCountedPointer.html#26757f1138dded33faeb1978004d0639">raw</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the raw pointer in T* context. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a2698fb8295dcab0c4bc1df9253c8509"></a><!-- doxytag: member="mysqlpp::RefCountedPointer::raw" ref="a2698fb8295dcab0c4bc1df9253c8509" args="() const " -->
const T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1RefCountedPointer.html#a2698fb8295dcab0c4bc1df9253c8509">raw</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the raw pointer when used in const T* context. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c6de38aa306bfe6166384e70bc9dbaef"></a><!-- doxytag: member="mysqlpp::RefCountedPointer::swap" ref="c6de38aa306bfe6166384e70bc9dbaef" args="(ThisType &amp;other)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1RefCountedPointer.html#c6de38aa306bfe6166384e70bc9dbaef">swap</a> (<a class="el" href="classmysqlpp_1_1RefCountedPointer.html">ThisType</a> &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exchange our managed memory with another pointer. <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class T, class Destroyer = RefCountedPointerDestroyer&lt;T&gt;&gt;<br>
 class mysqlpp::RefCountedPointer&lt; T, Destroyer &gt;</h3>

Creates an object that acts as a reference-counted pointer to another object. 
<p>
Resulting type acts like a pointer in all respects, except that it manages the memory it points to by observing how many users there are for the object.<p>
This attempts to be as automatic as reference counting in a programming language with memory management. Like all automatic memory management schemes, it has penalties: it turns the single indirection of an unmanaged pointer into a double indirection, and has additional management overhead in the assignment operators due to the reference counter. This is an acceptable tradeoff when wrapping objects that are expensive to copy, and which need to be "owned" by disparate parties: you can allocate the object just once, then pass around the reference counted pointer, knowing that the last user will "turn out the lights".<p>
<b>Implementation</b> <b>detail:</b> You may notice that this class manages two pointers, one to the data we're managing, and one to the reference count. You might wonder why we don't wrap these up into a structure and keep just a pointer to an instance of it to simplify the memory management. It would indeed do that, but then every access to the data we manage would be a triple indirection instead of just double. It's a tradeoff, and we've chosen to take a minor complexity hit to avoid the performance hit. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="02aa2860b0644b6333cee8f321477fee"></a><!-- doxytag: member="mysqlpp::RefCountedPointer::RefCountedPointer" ref="02aa2860b0644b6333cee8f321477fee" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Destroyer = RefCountedPointerDestroyer&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1RefCountedPointer.html">mysqlpp::RefCountedPointer</a>&lt; T, Destroyer &gt;::<a class="el" href="classmysqlpp_1_1RefCountedPointer.html">RefCountedPointer</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default constructor. 
<p>
An object constructed this way is useless until you vivify it with <a class="el" href="classmysqlpp_1_1RefCountedPointer.html#33e254256ace5abc2b07d8a630e55188">operator =()</a> or <a class="el" href="classmysqlpp_1_1RefCountedPointer.html#c6a54b0c4fdac3d05389639c5bc71168">assign()</a>. 
</div>
</div><p>
<a class="anchor" name="586313b144a88e487d77adf7d64bd3bb"></a><!-- doxytag: member="mysqlpp::RefCountedPointer::RefCountedPointer" ref="586313b144a88e487d77adf7d64bd3bb" args="(T *c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Destroyer = RefCountedPointerDestroyer&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1RefCountedPointer.html">mysqlpp::RefCountedPointer</a>&lt; T, Destroyer &gt;::<a class="el" href="classmysqlpp_1_1RefCountedPointer.html">RefCountedPointer</a>           </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>c</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Standard constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>A pointer to the object to be managed. If you pass 0, it's like calling the default ctor instead, only more work: the object's useless until you vivify it with <a class="el" href="classmysqlpp_1_1RefCountedPointer.html#33e254256ace5abc2b07d8a630e55188">operator =()</a> or <a class="el" href="classmysqlpp_1_1RefCountedPointer.html#c6a54b0c4fdac3d05389639c5bc71168">assign()</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="67b7d093310fa6112a45c361c37d5ed3"></a><!-- doxytag: member="mysqlpp::RefCountedPointer::~RefCountedPointer" ref="67b7d093310fa6112a45c361c37d5ed3" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Destroyer = RefCountedPointerDestroyer&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1RefCountedPointer.html">mysqlpp::RefCountedPointer</a>&lt; T, Destroyer &gt;::~<a class="el" href="classmysqlpp_1_1RefCountedPointer.html">RefCountedPointer</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>
This only destroys the managed memory if the reference count drops to 0. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a806e37d44b4d0384dc0bcd1deefd1b9"></a><!-- doxytag: member="mysqlpp::RefCountedPointer::assign" ref="a806e37d44b4d0384dc0bcd1deefd1b9" args="(const ThisType &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Destroyer = RefCountedPointerDestroyer&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1RefCountedPointer.html">ThisType</a>&amp; <a class="el" href="classmysqlpp_1_1RefCountedPointer.html">mysqlpp::RefCountedPointer</a>&lt; T, Destroyer &gt;::assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1RefCountedPointer.html">ThisType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy an existing refcounted pointer. 
<p>
If we are managing a pointer, this decrements the refcount for it and destroys the managed object if the refcount falls to 0. Then we increment the other object's reference count and copy that refcount and the managed pointer into this object.<p>
This is a no-op if you pass a reference to this same object. 
</div>
</div><p>
<a class="anchor" name="c6a54b0c4fdac3d05389639c5bc71168"></a><!-- doxytag: member="mysqlpp::RefCountedPointer::assign" ref="c6a54b0c4fdac3d05389639c5bc71168" args="(T *c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Destroyer = RefCountedPointerDestroyer&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1RefCountedPointer.html">ThisType</a>&amp; <a class="el" href="classmysqlpp_1_1RefCountedPointer.html">mysqlpp::RefCountedPointer</a>&lt; T, Destroyer &gt;::assign           </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>c</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets (or resets) the pointer to the counted object. 
<p>
If we are managing a pointer, this decrements the refcount for it and destroys the managed object if the refcount falls to 0.<p>
This is a no-op if you pass the same pointer we're already managing. 
</div>
</div><p>
<a class="anchor" name="067a0afe4a3f5ef1a6a68ddbcdced99a"></a><!-- doxytag: member="mysqlpp::RefCountedPointer::operator const void *" ref="067a0afe4a3f5ef1a6a68ddbcdced99a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Destroyer = RefCountedPointerDestroyer&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1RefCountedPointer.html">mysqlpp::RefCountedPointer</a>&lt; T, Destroyer &gt;::operator const void *           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the internal raw pointer converted to const void*. 
<p>
<dl compact><dt><b>See also:</b></dt><dd>comments for <a class="el" href="classmysqlpp_1_1RefCountedPointer.html#48f681f74dbe025e8c639f65850e2302">operator void*()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="48f681f74dbe025e8c639f65850e2302"></a><!-- doxytag: member="mysqlpp::RefCountedPointer::operator void *" ref="48f681f74dbe025e8c639f65850e2302" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Destroyer = RefCountedPointerDestroyer&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1RefCountedPointer.html">mysqlpp::RefCountedPointer</a>&lt; T, Destroyer &gt;::operator void *           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the internal raw pointer converted to void*. 
<p>
This isn't intended to be used directly; if you need the pointer, call <a class="el" href="classmysqlpp_1_1RefCountedPointer.html#26757f1138dded33faeb1978004d0639">raw()</a> instead. It's used internally by the compiler to implement operators bool, ==, and !=<p>
<b>WARNING:</b> This makes it possible to say <div class="fragment"><pre class="fragment">

        <span class="comment">/// </span>
</pre></div><p>
This will almost kinda sorta do the right thing: the Foo object held by the refcounted pointer will be destroyed as you wanted, but then when the refcounted pointer goes out of scope, the memory is deleted a second time, which will probably crash your program. This is easy to accidentally do when converting a good ol' unmanaged pointer to a refcounted pointer and forgetting to remove the delete calls needed previously. 
</div>
</div><p>
<a class="anchor" name="506a85c3e871b5436eb20d6436fb5d9d"></a><!-- doxytag: member="mysqlpp::RefCountedPointer::operator=" ref="506a85c3e871b5436eb20d6436fb5d9d" args="(const ThisType &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Destroyer = RefCountedPointerDestroyer&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1RefCountedPointer.html">ThisType</a>&amp; <a class="el" href="classmysqlpp_1_1RefCountedPointer.html">mysqlpp::RefCountedPointer</a>&lt; T, Destroyer &gt;::operator=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1RefCountedPointer.html">ThisType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy an existing refcounted pointer. 
<p>
This is essentially the same thing as <a class="el" href="classmysqlpp_1_1RefCountedPointer.html#a806e37d44b4d0384dc0bcd1deefd1b9">assign(const ThisType&amp;)</a>. The choice between the two is just a matter of syntactic preference. 
</div>
</div><p>
<a class="anchor" name="33e254256ace5abc2b07d8a630e55188"></a><!-- doxytag: member="mysqlpp::RefCountedPointer::operator=" ref="33e254256ace5abc2b07d8a630e55188" args="(T *c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class Destroyer = RefCountedPointerDestroyer&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1RefCountedPointer.html">ThisType</a>&amp; <a class="el" href="classmysqlpp_1_1RefCountedPointer.html">mysqlpp::RefCountedPointer</a>&lt; T, Destroyer &gt;::operator=           </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>c</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classmysqlpp_1_1Set.html">Set</a> (or reset) the pointer to the counted object. 
<p>
This is essentially the same thing as <a class="el" href="classmysqlpp_1_1RefCountedPointer.html#c6a54b0c4fdac3d05389639c5bc71168">assign(T*)</a>. The choice between the two is just a matter of syntactic preference. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="refcounted_8h-source.html">refcounted.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on 10 Dec 2013 for MySQL++ by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
