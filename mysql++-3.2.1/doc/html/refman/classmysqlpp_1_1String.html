<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
	<title>MySQL++ Reference Manual</title>
	<meta http-equiv="Content-type" content="text/html;charset=iso-8859-1">
	<link href="doxygen.css" rel="stylesheet" type="text/css">
	<link href="refman.css" rel="stylesheet" type="text/css">
</head>
<body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<b>mysqlpp</b>::<a class="el" href="classmysqlpp_1_1String.html">String</a></div>
<h1>mysqlpp::String Class Reference</h1><!-- doxytag: class="mysqlpp::String" -->A std::string work-alike that can convert itself from SQL text data formats to C++ data types.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="mystring_8h-source.html">mystring.h</a>&gt;</code>
<p>
Collaboration diagram for mysqlpp::String:<p><center><img src="classmysqlpp_1_1String__coll__graph.png" border="0" usemap="#mysqlpp_1_1String__coll__map" alt="Collaboration graph"></center>
<map name="mysqlpp_1_1String__coll__map">
<area href="classmysqlpp_1_1RefCountedPointer.html" shape="rect" coords="5,96,325,123" alt="">
</map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center><a href="classmysqlpp_1_1String-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f2ac840e79adca00ed4f3858ed1e1f75"></a><!-- doxytag: member="mysqlpp::String::value_type" ref="f2ac840e79adca00ed4f3858ed1e1f75" args="" -->
typedef const char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#f2ac840e79adca00ed4f3858ed1e1f75">value_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of the data stored in this object, when it is not equal to SQL null. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f5b6729bef9c0a50914a142c361c44b7"></a><!-- doxytag: member="mysqlpp::String::size_type" ref="f5b6729bef9c0a50914a142c361c44b7" args="" -->
typedef size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#f5b6729bef9c0a50914a142c361c44b7">size_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of "size" integers. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9c18cd6c1fb2d3130e80b10ff00550e5"></a><!-- doxytag: member="mysqlpp::String::const_iterator" ref="9c18cd6c1fb2d3130e80b10ff00550e5" args="" -->
typedef const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#9c18cd6c1fb2d3130e80b10ff00550e5">const_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of iterators. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c9a55310c5344694df502667a432cc3d"></a><!-- doxytag: member="mysqlpp::String::iterator" ref="c9a55310c5344694df502667a432cc3d" args="" -->
typedef <a class="el" href="classmysqlpp_1_1String.html#9c18cd6c1fb2d3130e80b10ff00550e5">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#c9a55310c5344694df502667a432cc3d">iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as const_iterator because the data cannot be changed. <br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#e711df130eb705131bb4121b58114304">String</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor.  <a href="#e711df130eb705131bb4121b58114304"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#7e81654babcc5d285b3e9f838833bd88">String</a> (const <a class="el" href="classmysqlpp_1_1String.html">String</a> &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy ctor.  <a href="#7e81654babcc5d285b3e9f838833bd88"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#f5ff5d5045cbca01c441d2b1b1b02136">String</a> (const char *str, <a class="el" href="classmysqlpp_1_1String.html#f5b6729bef9c0a50914a142c361c44b7">size_type</a> len, <a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a> type=<a class="el" href="classmysqlpp_1_1mysql__type__info.html#18d778e786cf06f63a7222129feed227">mysql_type_info::string_type</a>, bool is_null=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Full constructor.  <a href="#f5ff5d5045cbca01c441d2b1b1b02136"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#f6d39e2ae5aeb13761b80fafcfdcb8a0">String</a> (const std::string &amp;str, <a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a> type=<a class="el" href="classmysqlpp_1_1mysql__type__info.html#18d778e786cf06f63a7222129feed227">mysql_type_info::string_type</a>, bool is_null=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">C++ string version of full ctor.  <a href="#f6d39e2ae5aeb13761b80fafcfdcb8a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#fb546bc0f5231627b93c66746a9cd3c0">String</a> (const char *str, <a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a> type=<a class="el" href="classmysqlpp_1_1mysql__type__info.html#18d778e786cf06f63a7222129feed227">mysql_type_info::string_type</a>, bool is_null=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Null-terminated C string version of full ctor.  <a href="#fb546bc0f5231627b93c66746a9cd3c0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="43e145f153028b0932fe916159f803dc"></a><!-- doxytag: member="mysqlpp::String::~String" ref="43e145f153028b0932fe916159f803dc" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#43e145f153028b0932fe916159f803dc">~String</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy string. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#07d5fc7add1e11e9f11b8169a7f2c792">assign</a> (const char *str, <a class="el" href="classmysqlpp_1_1String.html#f5b6729bef9c0a50914a142c361c44b7">size_type</a> len, <a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a> type=<a class="el" href="classmysqlpp_1_1mysql__type__info.html#18d778e786cf06f63a7222129feed227">mysql_type_info::string_type</a>, bool is_null=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign raw data to this object.  <a href="#07d5fc7add1e11e9f11b8169a7f2c792"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#2495cd58ddbf6427747d8bbfefd4f5b7">assign</a> (const std::string &amp;str, <a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a> type=<a class="el" href="classmysqlpp_1_1mysql__type__info.html#18d778e786cf06f63a7222129feed227">mysql_type_info::string_type</a>, bool is_null=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign a C++ string to this object.  <a href="#2495cd58ddbf6427747d8bbfefd4f5b7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#30624cfe0e895bb2e20d653c35cca80c">assign</a> (const char *str, <a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a> type=<a class="el" href="classmysqlpp_1_1mysql__type__info.html#18d778e786cf06f63a7222129feed227">mysql_type_info::string_type</a>, bool is_null=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign a C string to this object.  <a href="#30624cfe0e895bb2e20d653c35cca80c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#d9503b161cf2146cf99c472dadbf0e16">at</a> (<a class="el" href="classmysqlpp_1_1String.html#f5b6729bef9c0a50914a142c361c44b7">size_type</a> pos) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a character within the string.  <a href="#d9503b161cf2146cf99c472dadbf0e16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f459c83601d1977d5ca2c3394d374f2c"></a><!-- doxytag: member="mysqlpp::String::begin" ref="f459c83601d1977d5ca2c3394d374f2c" args="() const " -->
<a class="el" href="classmysqlpp_1_1String.html#9c18cd6c1fb2d3130e80b10ff00550e5">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#f459c83601d1977d5ca2c3394d374f2c">begin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return iterator pointing to the first character of the string. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7b518885611f7f2275ef4da6205c8272"></a><!-- doxytag: member="mysqlpp::String::c_str" ref="7b518885611f7f2275ef4da6205c8272" args="() const " -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#7b518885611f7f2275ef4da6205c8272">c_str</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a const pointer to the string data. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="54b6aafa2f3c29a1aafc52cee99d298c"></a><!-- doxytag: member="mysqlpp::String::conv" ref="54b6aafa2f3c29a1aafc52cee99d298c" args="(Type) const " -->
template&lt;class Type&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#54b6aafa2f3c29a1aafc52cee99d298c">conv</a> (Type) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Template for converting the column data to most any numeric data type. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T, class B&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classmysqlpp_1_1Null.html">Null</a>&lt; T, B &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#ef842ddd728f7d98b7efcefb0be46a1a">conv</a> (<a class="el" href="classmysqlpp_1_1Null.html">Null</a>&lt; T, B &gt;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of <a class="el" href="classmysqlpp_1_1String.html#54b6aafa2f3c29a1aafc52cee99d298c">conv()</a> for types wrapped with Null&lt;&gt;.  <a href="#ef842ddd728f7d98b7efcefb0be46a1a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#9289c025d3e2900fd5b3fc6a0b971116">compare</a> (const <a class="el" href="classmysqlpp_1_1String.html">String</a> &amp;other) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lexically compare this string to another.  <a href="#9289c025d3e2900fd5b3fc6a0b971116"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#590200af942b7d3fa1e99c453fc5feee">compare</a> (const std::string &amp;other) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lexically compare this string to another.  <a href="#590200af942b7d3fa1e99c453fc5feee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#129f6059c6c35afa47e11f1786784467">compare</a> (<a class="el" href="classmysqlpp_1_1String.html#f5b6729bef9c0a50914a142c361c44b7">size_type</a> pos, <a class="el" href="classmysqlpp_1_1String.html#f5b6729bef9c0a50914a142c361c44b7">size_type</a> num, std::string &amp;other) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lexically compare this string to another.  <a href="#129f6059c6c35afa47e11f1786784467"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#924df971ce7e56b77c8cce404da4cd69">compare</a> (const char *other) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lexically compare this string to another.  <a href="#924df971ce7e56b77c8cce404da4cd69"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#426fc8b86291b85a29958440cc8725e4">compare</a> (<a class="el" href="classmysqlpp_1_1String.html#f5b6729bef9c0a50914a142c361c44b7">size_type</a> pos, <a class="el" href="classmysqlpp_1_1String.html#f5b6729bef9c0a50914a142c361c44b7">size_type</a> num, const char *other) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lexically compare this string to another.  <a href="#426fc8b86291b85a29958440cc8725e4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="75c91b53d9b2998d20c72b942dedc69f"></a><!-- doxytag: member="mysqlpp::String::data" ref="75c91b53d9b2998d20c72b942dedc69f" args="() const " -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#75c91b53d9b2998d20c72b942dedc69f">data</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Raw access to the underlying buffer, with no C string interpretation. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0e1cd5673ac2919cf05e2ce8bf99489d"></a><!-- doxytag: member="mysqlpp::String::empty" ref="0e1cd5673ac2919cf05e2ce8bf99489d" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#0e1cd5673ac2919cf05e2ce8bf99489d">empty</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if <a class="el" href="classmysqlpp_1_1String.html#cb5da2601dc9f7d50c0793d76ab94817">size()</a> == 0. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c45da6949d25235fb08146cc54423184"></a><!-- doxytag: member="mysqlpp::String::end" ref="c45da6949d25235fb08146cc54423184" args="() const " -->
<a class="el" href="classmysqlpp_1_1String.html#9c18cd6c1fb2d3130e80b10ff00550e5">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#c45da6949d25235fb08146cc54423184">end</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return iterator pointing to one past the last character of the string. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="693c487decac34ba8fcd78e8f77f822f"></a><!-- doxytag: member="mysqlpp::String::escape_q" ref="693c487decac34ba8fcd78e8f77f822f" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#693c487decac34ba8fcd78e8f77f822f">escape_q</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if data of this type should be escaped, false otherwise. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ae1a09ac03c7aedb4ce8242b64c99105"></a><!-- doxytag: member="mysqlpp::String::is_null" ref="ae1a09ac03c7aedb4ce8242b64c99105" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#ae1a09ac03c7aedb4ce8242b64c99105">is_null</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if this object is a SQL null. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c73442369274b0a9425061b8e0cc139f"></a><!-- doxytag: member="mysqlpp::String::it_is_null" ref="c73442369274b0a9425061b8e0cc139f" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#c73442369274b0a9425061b8e0cc139f">it_is_null</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classmysqlpp_1_1Set.html">Set</a> a flag indicating that this object is a SQL null. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classmysqlpp_1_1String.html#f5b6729bef9c0a50914a142c361c44b7">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#631286a235165cc9c2b653b5d852f65c">length</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return number of bytes in the string.  <a href="#631286a235165cc9c2b653b5d852f65c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classmysqlpp_1_1String.html#f5b6729bef9c0a50914a142c361c44b7">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#4e1e47982e7ad8f2cbe3da71be02999e">max_size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the maximum number of characters in the string.  <a href="#4e1e47982e7ad8f2cbe3da71be02999e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="15315731fe907f655c48018a4d86e484"></a><!-- doxytag: member="mysqlpp::String::quote_q" ref="15315731fe907f655c48018a4d86e484" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#15315731fe907f655c48018a4d86e484">quote_q</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if data of this type should be quoted, false otherwise. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classmysqlpp_1_1String.html#f5b6729bef9c0a50914a142c361c44b7">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#cb5da2601dc9f7d50c0793d76ab94817">size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return number of bytes in string.  <a href="#cb5da2601dc9f7d50c0793d76ab94817"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3deb0dc258c0e2920fba90fdf53baf97"></a><!-- doxytag: member="mysqlpp::String::strip_leading_blanks" ref="3deb0dc258c0e2920fba90fdf53baf97" args="(std::string &amp;s) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#3deb0dc258c0e2920fba90fdf53baf97">strip_leading_blanks</a> (std::string &amp;s) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a copy of our internal string without leading blanks. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#5832628cdfc820e57ddd44f16ad6c282">to_string</a> (std::string &amp;s) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies this object's data into a C++ string.  <a href="#5832628cdfc820e57ddd44f16ad6c282"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="54a1090c2f5a667937c2eb21b7ad3da6"></a><!-- doxytag: member="mysqlpp::String::type" ref="54a1090c2f5a667937c2eb21b7ad3da6" args="() const " -->
<a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#54a1090c2f5a667937c2eb21b7ad3da6">type</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get this object's current MySQL type. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6f31d730d66f311a4045bf62b170869d"></a><!-- doxytag: member="mysqlpp::String::operator=" ref="6f31d730d66f311a4045bf62b170869d" args="(const std::string &amp;rhs)" -->
<a class="el" href="classmysqlpp_1_1String.html">String</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#6f31d730d66f311a4045bf62b170869d">operator=</a> (const std::string &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator, from C++ string. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classmysqlpp_1_1String.html">String</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#7bc9c3f4dd56805e844aba503b175bcd">operator=</a> (const char *str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator, from C string.  <a href="#7bc9c3f4dd56805e844aba503b175bcd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classmysqlpp_1_1String.html">String</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#1252d1e232376f6493755b49761fa439">operator=</a> (const <a class="el" href="classmysqlpp_1_1String.html">String</a> &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator, from other <a class="el" href="classmysqlpp_1_1String.html">String</a>.  <a href="#1252d1e232376f6493755b49761fa439"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#410c81bd5c80effebb279af614c0a7c3">operator==</a> (const T &amp;rhs) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equality comparison operator.  <a href="#410c81bd5c80effebb279af614c0a7c3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#6704f745f7412724fed0caacdb321417">operator==</a> (const <a class="el" href="classmysqlpp_1_1null__type.html">mysqlpp::null_type</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equality comparison operator.  <a href="#6704f745f7412724fed0caacdb321417"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#63f7e9ac174f025cbaa5669c68c7489b">operator!=</a> (const T &amp;rhs) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inequality comparison operator.  <a href="#63f7e9ac174f025cbaa5669c68c7489b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#ed535131fdcff79909822ed937d99972">operator!=</a> (const <a class="el" href="classmysqlpp_1_1null__type.html">mysqlpp::null_type</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inequality comparison operator.  <a href="#ed535131fdcff79909822ed937d99972"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#f3604ef3820103e67d452b8b44dcd64d">operator[]</a> (<a class="el" href="classmysqlpp_1_1String.html#f5b6729bef9c0a50914a142c361c44b7">size_type</a> pos) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a character within the string.  <a href="#f3604ef3820103e67d452b8b44dcd64d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="dff63379de1888dc30b9fde8a55ed37a"></a><!-- doxytag: member="mysqlpp::String::operator const char *" ref="dff63379de1888dc30b9fde8a55ed37a" args="() const " -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#dff63379de1888dc30b9fde8a55ed37a">operator const char *</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a const char pointer to the object's raw data. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0b3452dfec79b5f8c42a232de1d308f5"></a><!-- doxytag: member="mysqlpp::String::operator signed char" ref="0b3452dfec79b5f8c42a232de1d308f5" args="() const " -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#0b3452dfec79b5f8c42a232de1d308f5">operator signed char</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts this object's string data to a signed char. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="844d4549644bef767b688b11b2f7d66a"></a><!-- doxytag: member="mysqlpp::String::operator unsigned char" ref="844d4549644bef767b688b11b2f7d66a" args="() const " -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#844d4549644bef767b688b11b2f7d66a">operator unsigned char</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts this object's string data to an unsigned char. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3dc5400a915fdb59677b676b5e8fe315"></a><!-- doxytag: member="mysqlpp::String::operator int" ref="3dc5400a915fdb59677b676b5e8fe315" args="() const " -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#3dc5400a915fdb59677b676b5e8fe315">operator int</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts this object's string data to an int. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7b05dc6f7f324b5bf73310bd944ef786"></a><!-- doxytag: member="mysqlpp::String::operator unsigned int" ref="7b05dc6f7f324b5bf73310bd944ef786" args="() const " -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#7b05dc6f7f324b5bf73310bd944ef786">operator unsigned int</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts this object's string data to an unsigned int. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5fb65923cc699ec38e98310380128f43"></a><!-- doxytag: member="mysqlpp::String::operator short int" ref="5fb65923cc699ec38e98310380128f43" args="() const " -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#5fb65923cc699ec38e98310380128f43">operator short int</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts this object's string data to a short int. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="578c493122d43ed4b14aae47f2a98756"></a><!-- doxytag: member="mysqlpp::String::operator unsigned short int" ref="578c493122d43ed4b14aae47f2a98756" args="() const " -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#578c493122d43ed4b14aae47f2a98756">operator unsigned short int</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts this object's string data to an unsigned short int. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f91bc9ccadbec83ff456c0eadc86458f"></a><!-- doxytag: member="mysqlpp::String::operator long int" ref="f91bc9ccadbec83ff456c0eadc86458f" args="() const " -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#f91bc9ccadbec83ff456c0eadc86458f">operator long int</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts this object's string data to a long int. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0f5b2c99c3a20e7ef312d8eebb298587"></a><!-- doxytag: member="mysqlpp::String::operator unsigned long int" ref="0f5b2c99c3a20e7ef312d8eebb298587" args="() const " -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#0f5b2c99c3a20e7ef312d8eebb298587">operator unsigned long int</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts this object's string data to an unsigned long int. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2f9bc5d60f4b4d72fbc00c6821d65cf7"></a><!-- doxytag: member="mysqlpp::String::operator longlong" ref="2f9bc5d60f4b4d72fbc00c6821d65cf7" args="() const " -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#2f9bc5d60f4b4d72fbc00c6821d65cf7">operator longlong</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts this object's string data to the platform- specific 'longlong' type, usually a 64-bit integer. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="174d4d0e643f1dd65d6ce2372d4d949d"></a><!-- doxytag: member="mysqlpp::String::operator ulonglong" ref="174d4d0e643f1dd65d6ce2372d4d949d" args="() const " -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#174d4d0e643f1dd65d6ce2372d4d949d">operator ulonglong</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts this object's string data to the platform- specific 'ulonglong' type, usually a 64-bit unsigned integer. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9df602a7f157ffcb64a2141435097d59"></a><!-- doxytag: member="mysqlpp::String::operator float" ref="9df602a7f157ffcb64a2141435097d59" args="() const " -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#9df602a7f157ffcb64a2141435097d59">operator float</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts this object's string data to a float. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7209b84d062d8f51a3a0b36ea2af69f3"></a><!-- doxytag: member="mysqlpp::String::operator double" ref="7209b84d062d8f51a3a0b36ea2af69f3" args="() const " -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#7209b84d062d8f51a3a0b36ea2af69f3">operator double</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts this object's string data to a double. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="67dfd8025327acec9edda4c03839f9e3"></a><!-- doxytag: member="mysqlpp::String::operator bool" ref="67dfd8025327acec9edda4c03839f9e3" args="() const " -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#67dfd8025327acec9edda4c03839f9e3">operator bool</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts this object's string data to a bool. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="09e4229af9eecd3592f74e3ffe036384"></a><!-- doxytag: member="mysqlpp::String::operator Date" ref="09e4229af9eecd3592f74e3ffe036384" args="() const " -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#09e4229af9eecd3592f74e3ffe036384">operator Date</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts this object's string data to a <a class="el" href="classmysqlpp_1_1Date.html">mysqlpp::Date</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="45cf4e66e39dc6a5c021550f50c2e830"></a><!-- doxytag: member="mysqlpp::String::operator DateTime" ref="45cf4e66e39dc6a5c021550f50c2e830" args="() const " -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#45cf4e66e39dc6a5c021550f50c2e830">operator DateTime</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts this object's string data to a <a class="el" href="classmysqlpp_1_1DateTime.html">mysqlpp::DateTime</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="888f0711a32d5a4184010ad0bb0bc524"></a><!-- doxytag: member="mysqlpp::String::operator Time" ref="888f0711a32d5a4184010ad0bb0bc524" args="() const " -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#888f0711a32d5a4184010ad0bb0bc524">operator Time</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts this object's string data to a <a class="el" href="classmysqlpp_1_1Time.html">mysqlpp::Time</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T, class B&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1String.html#14ef54545b7a605692fe26bcae55f7f9">operator Null</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts the <a class="el" href="classmysqlpp_1_1String.html">String</a> to a nullable data type.  <a href="#14ef54545b7a605692fe26bcae55f7f9"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="970c115220fc891e05eef4cc92705457"></a><!-- doxytag: member="mysqlpp::String::SQLTypeAdapter" ref="970c115220fc891e05eef4cc92705457" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>SQLTypeAdapter</b></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A std::string work-alike that can convert itself from SQL text data formats to C++ data types. 
<p>
This class is an intermediate form for a SQL field, normally converted to a more useful native C++ type, not used directly. The only exception is in dealing with BLOB data, which stays in <a class="el" href="classmysqlpp_1_1String.html">String</a> form for efficiency and to avoid corrupting the data with facile conversions. Even then, it's best to use it through the typedef aliases like sql_blob in <a class="el" href="sql__types_8h.html">sql_types.h</a>, in case we later change this underlying representation.<p>
String's implicit conversion operators let you can use these objects naturally:<p>
<div class="fragment"><pre class="fragment"> <a class="code" href="classmysqlpp_1_1String.html#e711df130eb705131bb4121b58114304">String</a>(<span class="stringliteral">"12.86"</span>) + 2.0 
</pre></div><p>
That will give you 14.86 (approximately) as you expect, but be careful not to get tripped up by C++'s type conversion rules. If you had said this instead:<p>
<div class="fragment"><pre class="fragment"> <a class="code" href="classmysqlpp_1_1String.html#e711df130eb705131bb4121b58114304">String</a>(<span class="stringliteral">"12.86"</span>) + 2 
</pre></div><p>
the result would be 14 because 2 is an integer, and C++'s type conversion rules put the <a class="el" href="classmysqlpp_1_1String.html">String</a> object in an integer context.<p>
You can disable the operator overloads that allow these things by defining MYSQLPP_NO_BINARY_OPERS.<p>
This class also has some basic information about the type of data stored in it, to allow it to do the conversions more intelligently than a trivial implementation would allow. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="e711df130eb705131bb4121b58114304"></a><!-- doxytag: member="mysqlpp::String::String" ref="e711df130eb705131bb4121b58114304" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mysqlpp::String::String           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default constructor. 
<p>
An object constructed this way is essentially useless, but sometimes you just need to construct a default object. 
</div>
</div><p>
<a class="anchor" name="7e81654babcc5d285b3e9f838833bd88"></a><!-- doxytag: member="mysqlpp::String::String" ref="7e81654babcc5d285b3e9f838833bd88" args="(const String &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mysqlpp::String::String           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy ctor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>the other <a class="el" href="classmysqlpp_1_1String.html">String</a> object</td></tr>
  </table>
</dl>
This ctor only copies the pointer to the other String's data buffer and increments its reference counter. If you need a deep copy, use one of the ctors that takes a string. 
</div>
</div><p>
<a class="anchor" name="f5ff5d5045cbca01c441d2b1b1b02136"></a><!-- doxytag: member="mysqlpp::String::String" ref="f5ff5d5045cbca01c441d2b1b1b02136" args="(const char *str, size_type len, mysql_type_info type=mysql_type_info::string_type, bool is_null=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mysqlpp::String::String           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1String.html#f5b6729bef9c0a50914a142c361c44b7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a>&nbsp;</td>
          <td class="paramname"> <em>type</em> = <code><a class="el" href="classmysqlpp_1_1mysql__type__info.html#18d778e786cf06f63a7222129feed227">mysql_type_info::string_type</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>is_null</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Full constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>the string this object represents, or 0 for SQL null </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>the length of the string; embedded nulls are legal </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>MySQL type information for data within str </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>is_null</em>&nbsp;</td><td>string represents a SQL null, not literal data</td></tr>
  </table>
</dl>
The resulting object will contain a copy of the string buffer. The buffer will actually be 1 byte longer than the value given for <code>len</code>, to hold a null terminator for safety. We do this because this ctor may be used for things other than null-terminated C strings. (e.g. BLOB data) 
</div>
</div><p>
<a class="anchor" name="f6d39e2ae5aeb13761b80fafcfdcb8a0"></a><!-- doxytag: member="mysqlpp::String::String" ref="f6d39e2ae5aeb13761b80fafcfdcb8a0" args="(const std::string &amp;str, mysql_type_info type=mysql_type_info::string_type, bool is_null=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mysqlpp::String::String           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a>&nbsp;</td>
          <td class="paramname"> <em>type</em> = <code><a class="el" href="classmysqlpp_1_1mysql__type__info.html#18d778e786cf06f63a7222129feed227">mysql_type_info::string_type</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>is_null</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
C++ string version of full ctor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>the string this object represents, or 0 for SQL null </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>MySQL type information for data within str </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>is_null</em>&nbsp;</td><td>string represents a SQL null, not literal data</td></tr>
  </table>
</dl>
The resulting object will contain a copy of the string buffer. 
</div>
</div><p>
<a class="anchor" name="fb546bc0f5231627b93c66746a9cd3c0"></a><!-- doxytag: member="mysqlpp::String::String" ref="fb546bc0f5231627b93c66746a9cd3c0" args="(const char *str, mysql_type_info type=mysql_type_info::string_type, bool is_null=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mysqlpp::String::String           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a>&nbsp;</td>
          <td class="paramname"> <em>type</em> = <code><a class="el" href="classmysqlpp_1_1mysql__type__info.html#18d778e786cf06f63a7222129feed227">mysql_type_info::string_type</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>is_null</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Null-terminated C string version of full ctor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>the string this object represents, or 0 for SQL null </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>MySQL type information for data within str </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>is_null</em>&nbsp;</td><td>string represents a SQL null, not literal data</td></tr>
  </table>
</dl>
The resulting object will contain a copy of the string buffer. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="30624cfe0e895bb2e20d653c35cca80c"></a><!-- doxytag: member="mysqlpp::String::assign" ref="30624cfe0e895bb2e20d653c35cca80c" args="(const char *str, mysql_type_info type=mysql_type_info::string_type, bool is_null=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mysqlpp::String::assign           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a>&nbsp;</td>
          <td class="paramname"> <em>type</em> = <code><a class="el" href="classmysqlpp_1_1mysql__type__info.html#18d778e786cf06f63a7222129feed227">mysql_type_info::string_type</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>is_null</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assign a C string to this object. 
<p>
This parallels the ctor with the same parameters, for when you must do a 2-step create, or when you want to reassign the data without creating a <a class="el" href="classmysqlpp_1_1String.html">String</a> temporary to get around the fact that <a class="el" href="classmysqlpp_1_1String.html#6f31d730d66f311a4045bf62b170869d">operator=()</a> can only take one parameter. 
</div>
</div><p>
<a class="anchor" name="2495cd58ddbf6427747d8bbfefd4f5b7"></a><!-- doxytag: member="mysqlpp::String::assign" ref="2495cd58ddbf6427747d8bbfefd4f5b7" args="(const std::string &amp;str, mysql_type_info type=mysql_type_info::string_type, bool is_null=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mysqlpp::String::assign           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a>&nbsp;</td>
          <td class="paramname"> <em>type</em> = <code><a class="el" href="classmysqlpp_1_1mysql__type__info.html#18d778e786cf06f63a7222129feed227">mysql_type_info::string_type</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>is_null</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assign a C++ string to this object. 
<p>
This parallels the ctor with the same parameters, for when you must do a 2-step create, or when you want to reassign the data without creating a <a class="el" href="classmysqlpp_1_1String.html">String</a> temporary to get around the fact that <a class="el" href="classmysqlpp_1_1String.html#6f31d730d66f311a4045bf62b170869d">operator=()</a> can only take one parameter. 
</div>
</div><p>
<a class="anchor" name="07d5fc7add1e11e9f11b8169a7f2c792"></a><!-- doxytag: member="mysqlpp::String::assign" ref="07d5fc7add1e11e9f11b8169a7f2c792" args="(const char *str, size_type len, mysql_type_info type=mysql_type_info::string_type, bool is_null=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mysqlpp::String::assign           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1String.html#f5b6729bef9c0a50914a142c361c44b7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a>&nbsp;</td>
          <td class="paramname"> <em>type</em> = <code><a class="el" href="classmysqlpp_1_1mysql__type__info.html#18d778e786cf06f63a7222129feed227">mysql_type_info::string_type</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>is_null</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assign raw data to this object. 
<p>
This parallels the ctor with the same parameters, for when you must do a 2-step create, or when you want to reassign the data without creating a <a class="el" href="classmysqlpp_1_1String.html">String</a> temporary to get around the fact that <a class="el" href="classmysqlpp_1_1String.html#6f31d730d66f311a4045bf62b170869d">operator=()</a> can only take one parameter. 
</div>
</div><p>
<a class="anchor" name="d9503b161cf2146cf99c472dadbf0e16"></a><!-- doxytag: member="mysqlpp::String::at" ref="d9503b161cf2146cf99c472dadbf0e16" args="(size_type pos) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char mysqlpp::String::at           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1String.html#f5b6729bef9c0a50914a142c361c44b7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>pos</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a character within the string. 
<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classmysqlpp_1_1BadIndex.html">mysqlpp::BadIndex</a></em>&nbsp;</td><td>if the row is not initialized or there are less than <code>i</code> fields in the row. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="426fc8b86291b85a29958440cc8725e4"></a><!-- doxytag: member="mysqlpp::String::compare" ref="426fc8b86291b85a29958440cc8725e4" args="(size_type pos, size_type num, const char *other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mysqlpp::String::compare           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1String.html#f5b6729bef9c0a50914a142c361c44b7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1String.html#f5b6729bef9c0a50914a142c361c44b7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lexically compare this string to another. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>position within this string to begin comparison </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td>maximum number of characters within this string to use in comparison </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>string to compare against this one</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>&lt;</em>&nbsp;</td><td>0 if this string is lexically "less than" other </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>if this string is equal to other </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>&gt;</em>&nbsp;</td><td>0 if this string is lexically "greater than" other </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="924df971ce7e56b77c8cce404da4cd69"></a><!-- doxytag: member="mysqlpp::String::compare" ref="924df971ce7e56b77c8cce404da4cd69" args="(const char *other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mysqlpp::String::compare           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lexically compare this string to another. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>string to compare against this one</td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd>compare(size_type, size_type, const char*) </dd></dl>

</div>
</div><p>
<a class="anchor" name="129f6059c6c35afa47e11f1786784467"></a><!-- doxytag: member="mysqlpp::String::compare" ref="129f6059c6c35afa47e11f1786784467" args="(size_type pos, size_type num, std::string &amp;other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mysqlpp::String::compare           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1String.html#f5b6729bef9c0a50914a142c361c44b7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1String.html#f5b6729bef9c0a50914a142c361c44b7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lexically compare this string to another. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>position within this string to begin comparison </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td>maximum number of characters within this string to use in comparison </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>string to compare against this one</td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd>compare(size_type, size_type, const char*) </dd></dl>

</div>
</div><p>
<a class="anchor" name="590200af942b7d3fa1e99c453fc5feee"></a><!-- doxytag: member="mysqlpp::String::compare" ref="590200af942b7d3fa1e99c453fc5feee" args="(const std::string &amp;other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mysqlpp::String::compare           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lexically compare this string to another. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>string to compare against this one</td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd>compare(size_type, size_type, const char*) </dd></dl>

</div>
</div><p>
<a class="anchor" name="9289c025d3e2900fd5b3fc6a0b971116"></a><!-- doxytag: member="mysqlpp::String::compare" ref="9289c025d3e2900fd5b3fc6a0b971116" args="(const String &amp;other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mysqlpp::String::compare           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lexically compare this string to another. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>string to compare against this one</td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd>compare(size_type, size_type, const char*) </dd></dl>

</div>
</div><p>
<a class="anchor" name="ef842ddd728f7d98b7efcefb0be46a1a"></a><!-- doxytag: member="mysqlpp::String::conv" ref="ef842ddd728f7d98b7efcefb0be46a1a" args="(Null&lt; T, B &gt;) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class B&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1Null.html">Null</a>&lt;T, B&gt; mysqlpp::String::conv           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1Null.html">Null</a>&lt; T, B &gt;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overload of <a class="el" href="classmysqlpp_1_1String.html#54b6aafa2f3c29a1aafc52cee99d298c">conv()</a> for types wrapped with Null&lt;&gt;. 
<p>
If the <a class="el" href="classmysqlpp_1_1String.html">String</a> object was initialized with some string we recognize as a SQL null, we just return a copy of the global 'null' object converted to the requested type. Otherwise, we return the String's value wrapped in the Null&lt;&gt; template. 
</div>
</div><p>
<a class="anchor" name="631286a235165cc9c2b653b5d852f65c"></a><!-- doxytag: member="mysqlpp::String::length" ref="631286a235165cc9c2b653b5d852f65c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1String.html#f5b6729bef9c0a50914a142c361c44b7">String::size_type</a> mysqlpp::String::length           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return number of bytes in the string. 
<p>
Note that this doesn't count the number of <b>characters</b> in the string. If your database is configured to use an 8-bit character set, this is a distinction without a difference. But, if you're using UTF-8 in the database, you will need to "widen" the UTF-8 data to use a fixed-size character set like UCS-2 and count the characters that way. You might use std::wstring, for example. 
</div>
</div><p>
<a class="anchor" name="4e1e47982e7ad8f2cbe3da71be02999e"></a><!-- doxytag: member="mysqlpp::String::max_size" ref="4e1e47982e7ad8f2cbe3da71be02999e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1String.html#f5b6729bef9c0a50914a142c361c44b7">size_type</a> mysqlpp::String::max_size           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the maximum number of characters in the string. 
<p>
Because this is a <code>const</code> string, this is just an alias for <a class="el" href="classmysqlpp_1_1String.html#cb5da2601dc9f7d50c0793d76ab94817">size()</a>; its size is always equal to the amount of data currently stored. 
</div>
</div><p>
<a class="anchor" name="14ef54545b7a605692fe26bcae55f7f9"></a><!-- doxytag: member="mysqlpp::String::operator Null" ref="14ef54545b7a605692fe26bcae55f7f9" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class B&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mysqlpp::String::operator <a class="el" href="classmysqlpp_1_1Null.html">Null</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts the <a class="el" href="classmysqlpp_1_1String.html">String</a> to a nullable data type. 
<p>
This is just an implicit version of conv(Null&lt;T, B&gt;) 
</div>
</div><p>
<a class="anchor" name="ed535131fdcff79909822ed937d99972"></a><!-- doxytag: member="mysqlpp::String::operator!=" ref="ed535131fdcff79909822ed937d99972" args="(const mysqlpp::null_type &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mysqlpp::String::operator!=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1null__type.html">mysqlpp::null_type</a> &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inequality comparison operator. 
<p>
For checking object against MySQL++'s global <code>null</code> constant 
</div>
</div><p>
<a class="anchor" name="63f7e9ac174f025cbaa5669c68c7489b"></a><!-- doxytag: member="mysqlpp::String::operator!=" ref="63f7e9ac174f025cbaa5669c68c7489b" args="(const T &amp;rhs) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mysqlpp::String::operator!=           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inequality comparison operator. 
<p>
For comparing this object to any of the data types we have a <a class="el" href="classmysqlpp_1_1String.html#9289c025d3e2900fd5b3fc6a0b971116">compare()</a> overload for. 
</div>
</div><p>
<a class="anchor" name="1252d1e232376f6493755b49761fa439"></a><!-- doxytag: member="mysqlpp::String::operator=" ref="1252d1e232376f6493755b49761fa439" args="(const String &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1String.html">String</a>&amp; mysqlpp::String::operator=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1String.html">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assignment operator, from other <a class="el" href="classmysqlpp_1_1String.html">String</a>. 
<p>
This only copies the pointer to the other String's data buffer and increments its reference counter. If you need a deep copy, assign a string to this object instead. 
</div>
</div><p>
<a class="anchor" name="7bc9c3f4dd56805e844aba503b175bcd"></a><!-- doxytag: member="mysqlpp::String::operator=" ref="7bc9c3f4dd56805e844aba503b175bcd" args="(const char *str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1String.html">String</a>&amp; mysqlpp::String::operator=           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assignment operator, from C string. 
<p>
This creates a copy of the entire string, not just a copy of the pointer. 
</div>
</div><p>
<a class="anchor" name="6704f745f7412724fed0caacdb321417"></a><!-- doxytag: member="mysqlpp::String::operator==" ref="6704f745f7412724fed0caacdb321417" args="(const mysqlpp::null_type &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mysqlpp::String::operator==           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1null__type.html">mysqlpp::null_type</a> &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equality comparison operator. 
<p>
For checking object against MySQL++'s global <code>null</code> constant 
</div>
</div><p>
<a class="anchor" name="410c81bd5c80effebb279af614c0a7c3"></a><!-- doxytag: member="mysqlpp::String::operator==" ref="410c81bd5c80effebb279af614c0a7c3" args="(const T &amp;rhs) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mysqlpp::String::operator==           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equality comparison operator. 
<p>
For comparing this object to any of the data types we have a <a class="el" href="classmysqlpp_1_1String.html#9289c025d3e2900fd5b3fc6a0b971116">compare()</a> overload for. 
</div>
</div><p>
<a class="anchor" name="f3604ef3820103e67d452b8b44dcd64d"></a><!-- doxytag: member="mysqlpp::String::operator[]" ref="f3604ef3820103e67d452b8b44dcd64d" args="(size_type pos) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char mysqlpp::String::operator[]           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1String.html#f5b6729bef9c0a50914a142c361c44b7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>pos</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a character within the string. 
<p>
This function is just syntactic sugar, wrapping the <a class="el" href="classmysqlpp_1_1String.html#d9503b161cf2146cf99c472dadbf0e16">at()</a> method.<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classmysqlpp_1_1BadIndex.html">mysqlpp::BadIndex</a></em>&nbsp;</td><td>if the string is not initialized or there are less than <code>i</code> fields in the string. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="cb5da2601dc9f7d50c0793d76ab94817"></a><!-- doxytag: member="mysqlpp::String::size" ref="cb5da2601dc9f7d50c0793d76ab94817" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1String.html#f5b6729bef9c0a50914a142c361c44b7">size_type</a> mysqlpp::String::size           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return number of bytes in string. 
<p>
See commentary for <a class="el" href="classmysqlpp_1_1String.html#631286a235165cc9c2b653b5d852f65c">length()</a> about the difference between bytes and characters. 
</div>
</div><p>
<a class="anchor" name="5832628cdfc820e57ddd44f16ad6c282"></a><!-- doxytag: member="mysqlpp::String::to_string" ref="5832628cdfc820e57ddd44f16ad6c282" args="(std::string &amp;s) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mysqlpp::String::to_string           </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies this object's data into a C++ string. 
<p>
If you know the data doesn't contain null characters (i.e. it's a typical string, not BLOB data), it's more efficient to just assign this object to anything taking <code>const</code> <code>char*</code>. (Or equivalently, call the <code><a class="el" href="classmysqlpp_1_1String.html#75c91b53d9b2998d20c72b942dedc69f">data()</a></code> method.) This copies a pointer to a buffer instead of copying the buffer's contents. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="mystring_8h-source.html">mystring.h</a><li>mystring.cpp</ul>
<hr size="1"><address style="align: right;"><small>Generated on 10 Dec 2013 for MySQL++ by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
