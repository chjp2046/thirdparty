<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
	<title>MySQL++ Reference Manual</title>
	<meta http-equiv="Content-type" content="text/html;charset=iso-8859-1">
	<link href="doxygen.css" rel="stylesheet" type="text/css">
	<link href="refman.css" rel="stylesheet" type="text/css">
</head>
<body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<b>mysqlpp</b>::<a class="el" href="classmysqlpp_1_1Query.html">Query</a></div>
<h1>mysqlpp::Query Class Reference</h1><!-- doxytag: class="mysqlpp::Query" --><!-- doxytag: inherits="mysqlpp::OptionalExceptions" -->A class for building and executing SQL queries.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="query_8h-source.html">query.h</a>&gt;</code>
<p>
Inheritance diagram for mysqlpp::Query:<p><center><img src="classmysqlpp_1_1Query__inherit__graph.png" border="0" usemap="#mysqlpp_1_1Query__inherit__map" alt="Inheritance graph"></center>
<map name="mysqlpp_1_1Query__inherit__map">
<area href="classmysqlpp_1_1OptionalExceptions.html" shape="rect" coords="5,5,219,32" alt="">
</map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center>Collaboration diagram for mysqlpp::Query:<p><center><img src="classmysqlpp_1_1Query__coll__graph.png" border="0" usemap="#mysqlpp_1_1Query__coll__map" alt="Collaboration graph"></center>
<map name="mysqlpp_1_1Query__coll__map">
<area href="classmysqlpp_1_1SQLQueryParms.html" shape="rect" coords="84,368,276,395" alt="">
<area href="classmysqlpp_1_1OptionalExceptions.html" shape="rect" coords="5,96,219,123" alt="">
<area href="classmysqlpp_1_1Connection.html" shape="rect" coords="177,187,337,213" alt="">
<area href="classmysqlpp_1_1DBDriver.html" shape="rect" coords="395,96,541,123" alt="">
</map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center><a href="classmysqlpp_1_1Query-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#6c6cbae18ebcb31b6d44e7784d5a3daa">Query</a> (<a class="el" href="classmysqlpp_1_1Connection.html">Connection</a> *c, bool te=true, const char *qstr=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new query object attached to a connection.  <a href="#6c6cbae18ebcb31b6d44e7784d5a3daa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#936b1062bb31b3428ead059a26590b6b">Query</a> (const <a class="el" href="classmysqlpp_1_1Query.html">Query</a> &amp;q)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new query object as a copy of another.  <a href="#936b1062bb31b3428ead059a26590b6b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="80d0b71c5cb23f70ebc0d27f0ecc3adc"></a><!-- doxytag: member="mysqlpp::Query::affected_rows" ref="80d0b71c5cb23f70ebc0d27f0ecc3adc" args="()" -->
ulonglong&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#80d0b71c5cb23f70ebc0d27f0ecc3adc">affected_rows</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of rows affected by the last query. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#dc7d259cbf78f1e418b7ad12751c5342">escape_string</a> (std::string *ps, const char *original=0, size_t length=0) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a SQL-escaped version of a character buffer.  <a href="#dc7d259cbf78f1e418b7ad12751c5342"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#b9061afbd8f1c03751b92b8ec6ba0de9">escape_string</a> (char *escaped, const char *original, size_t length) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a SQL-escaped version of the given character buffer.  <a href="#b9061afbd8f1c03751b92b8ec6ba0de9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#3acf442e091bdfb5344cbe9990f05f3b">errnum</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the last error number that was set.  <a href="#3acf442e091bdfb5344cbe9990f05f3b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#24ddaff8ae037c56c1a5aceda34e89c8">error</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the last error message that was set.  <a href="#24ddaff8ae037c56c1a5aceda34e89c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fecef4fce9f76f19ee82ad5a4bece19f"></a><!-- doxytag: member="mysqlpp::Query::info" ref="fecef4fce9f76f19ee82ad5a4bece19f" args="()" -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#fecef4fce9f76f19ee82ad5a4bece19f">info</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns information about the most recently executed query. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ulonglong&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#a15198c894157a099154be69201b5baf">insert_id</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get ID generated for an AUTO_INCREMENT column in the previous INSERT query.  <a href="#a15198c894157a099154be69201b5baf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classmysqlpp_1_1Query.html">Query</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#75982ff4f3b5fe603ee6041ed64172ce">operator=</a> (const <a class="el" href="classmysqlpp_1_1Query.html">Query</a> &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign another query's state to this object.  <a href="#75982ff4f3b5fe603ee6041ed64172ce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#9c2ff95a7cd013758cb1ad9984a7b74e">operator void *</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test whether the object has experienced an error condition.  <a href="#9c2ff95a7cd013758cb1ad9984a7b74e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#dc5e3d5604dbe48cda5d8d2e64d896f4">operator!</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the query object is not in a bad state.  <a href="#dc5e3d5604dbe48cda5d8d2e64d896f4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#5bfc86346581917cb833ed55ccd4d5b8">parse</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Treat the contents of the query string as a template query.  <a href="#5bfc86346581917cb833ed55ccd4d5b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#f12740e420c1d61b1d9c2995459a3ce0">reset</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the query object so that it can be reused.  <a href="#f12740e420c1d61b1d9c2995459a3ce0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#b02c4ab2f46159d9d45bfd2bbe57e2b4">result_empty</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the most recent result set was empty.  <a href="#b02c4ab2f46159d9d45bfd2bbe57e2b4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="17036cdcf4dd7a747b1ba6ee664da048"></a><!-- doxytag: member="mysqlpp::Query::str" ref="17036cdcf4dd7a747b1ba6ee664da048" args="()" -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#17036cdcf4dd7a747b1ba6ee664da048">str</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get built query as a C++ string. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#7fa8d56bd3d8a1bd3b5403665dbf6c8e">str</a> (const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;arg0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get built query as a C++ string with template query parameter substitution.  <a href="#7fa8d56bd3d8a1bd3b5403665dbf6c8e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#c93d201c91a7e0b9056e8cac33a38f7d">str</a> (<a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp;p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get built query as a null-terminated C++ string.  <a href="#c93d201c91a7e0b9056e8cac33a38f7d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#23057cc385f9645d7d7ef00aecc2c8ba">exec</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute a built-up query.  <a href="#23057cc385f9645d7d7ef00aecc2c8ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#985acb52d0a988d1800c8fc4f4c5dc06">exec</a> (const std::string &amp;str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute a query.  <a href="#985acb52d0a988d1800c8fc4f4c5dc06"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classmysqlpp_1_1SimpleResult.html">SimpleResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#03ee1b9e393d88de946f5be804ea88cf">execute</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute built-up query.  <a href="#03ee1b9e393d88de946f5be804ea88cf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classmysqlpp_1_1SimpleResult.html">SimpleResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#af36ce2e47a62fae2cc507a7750d1ecd">execute</a> (<a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp;p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute template query using given parameters.  <a href="#af36ce2e47a62fae2cc507a7750d1ecd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classmysqlpp_1_1SimpleResult.html">SimpleResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#f2cc737d916e4e1c9fd0392316e5415c">execute</a> (const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute a query that returns no rows.  <a href="#f2cc737d916e4e1c9fd0392316e5415c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classmysqlpp_1_1SimpleResult.html">SimpleResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#1faab5676c797dac619c6c98dc264e3c">execute</a> (const char *str, size_t len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute query in a known-length string of characters. This can include null characters.  <a href="#1faab5676c797dac619c6c98dc264e3c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classmysqlpp_1_1UseQueryResult.html">UseQueryResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#8538e92f55a5536bbf7704d27151ed87">use</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute a query that can return rows, with access to the rows in sequence.  <a href="#8538e92f55a5536bbf7704d27151ed87"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classmysqlpp_1_1UseQueryResult.html">UseQueryResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#66040c8c0071b50b043e8031309f7852">use</a> (<a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp;p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute a template query that can return rows, with access to the rows in sequence.  <a href="#66040c8c0071b50b043e8031309f7852"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classmysqlpp_1_1UseQueryResult.html">UseQueryResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#fe90361bc4f17f78c11857d32538dabe">use</a> (const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute a query that can return rows, with access to the rows in sequence.  <a href="#fe90361bc4f17f78c11857d32538dabe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classmysqlpp_1_1UseQueryResult.html">UseQueryResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#b00af2e285dbb32eb51de17e567d8b00">use</a> (const char *str, size_t len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute a query that can return rows, with access to the rows in sequence.  <a href="#b00af2e285dbb32eb51de17e567d8b00"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classmysqlpp_1_1StoreQueryResult.html">StoreQueryResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#16c800e645429d558f4295065b1aed73">store</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute a query that can return a result set.  <a href="#16c800e645429d558f4295065b1aed73"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classmysqlpp_1_1StoreQueryResult.html">StoreQueryResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#2bcd3c940f936f38bd40396449007d80">store</a> (<a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp;p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store results from a template query using given parameters.  <a href="#2bcd3c940f936f38bd40396449007d80"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classmysqlpp_1_1StoreQueryResult.html">StoreQueryResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#4531cbffbb15c003ff35c3bbbd3b4397">store</a> (const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute a query that can return rows, returning all of the rows in a random-access container.  <a href="#4531cbffbb15c003ff35c3bbbd3b4397"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classmysqlpp_1_1StoreQueryResult.html">StoreQueryResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#15f991f68505f9a35aed0a03932a1900">store</a> (const char *str, size_t len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute a query that can return rows, returning all of the rows in a random-access container.  <a href="#15f991f68505f9a35aed0a03932a1900"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Function&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Function&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#806794716f7f97b1f76ccdc6c3f548d0">for_each</a> (const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;query, Function fn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute a query, and call a functor for each returned row.  <a href="#806794716f7f97b1f76ccdc6c3f548d0"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Function&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Function&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#70a1c1be5272b8ee06c8fa0b20172423">for_each</a> (Function fn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute the query, and call a functor for each returned row.  <a href="#70a1c1be5272b8ee06c8fa0b20172423"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class SSQLS, typename Function&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Function&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#0143fa17dcc54047c9a72678f0df042e">for_each</a> (const SSQLS &amp;ssqls, Function fn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Run a functor for every row in a table.  <a href="#0143fa17dcc54047c9a72678f0df042e"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Sequence, typename Function&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Function&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#e15ceb094cba199c3aad5ae99b77d12b">store_if</a> (Sequence &amp;con, const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;query, Function fn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute a query, conditionally storing each row in a container.  <a href="#e15ceb094cba199c3aad5ae99b77d12b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Sequence, class SSQLS, typename Function&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Function&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#04f4039dd658f7a4943cdb373543b4da">store_if</a> (Sequence &amp;con, const SSQLS &amp;ssqls, Function fn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pulls every row in a table, conditionally storing each one in a container.  <a href="#04f4039dd658f7a4943cdb373543b4da"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Sequence, typename Function&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Function&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#c2ef13c964fc2d7f49fe38d7d8202ea4">store_if</a> (Sequence &amp;con, Function fn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute the query, conditionally storing each row in a container.  <a href="#c2ef13c964fc2d7f49fe38d7d8202ea4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classmysqlpp_1_1StoreQueryResult.html">StoreQueryResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#0e22c60aa550675b5e89ab9bbaea7f8e">store_next</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return next result set, when processing a multi-query.  <a href="#0e22c60aa550675b5e89ab9bbaea7f8e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#eeaff6b3fb94ff4bcad4046a833ee2ed">more_results</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return whether more results are waiting for a multi-query or stored procedure response.  <a href="#eeaff6b3fb94ff4bcad4046a833ee2ed"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Sequence&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#ef0903637280a12ca40b1d670ed502c0">storein_sequence</a> (Sequence &amp;con)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute a query, storing the result set in an STL sequence container.  <a href="#ef0903637280a12ca40b1d670ed502c0"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Sequence&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#2991cd00cec285d0ab5f8763de8fa677">storein_sequence</a> (Sequence &amp;con, const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Executes a query, storing the result rows in an STL sequence container.  <a href="#2991cd00cec285d0ab5f8763de8fa677"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Seq&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#d17b208852e71f054ed7e44f0ee56778">storein_sequence</a> (Seq &amp;con, <a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp;p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute template query using given parameters, storing the results in a sequence type container.  <a href="#d17b208852e71f054ed7e44f0ee56778"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Set&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#002234020d65383e07b4351177e1c368">storein_set</a> (<a class="el" href="classmysqlpp_1_1Set.html">Set</a> &amp;con)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute a query, storing the result set in an STL associative container.  <a href="#002234020d65383e07b4351177e1c368"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Set&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#c930f8c58075c84786536ad586ae8ffe">storein_set</a> (<a class="el" href="classmysqlpp_1_1Set.html">Set</a> &amp;con, const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Executes a query, storing the result rows in an STL set-associative container.  <a href="#c930f8c58075c84786536ad586ae8ffe"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Set&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#3ae482e561d54f7020b7e3a67f1f6342">storein_set</a> (<a class="el" href="classmysqlpp_1_1Set.html">Set</a> &amp;con, <a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp;p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute template query using given parameters, storing the results in a set type container.  <a href="#3ae482e561d54f7020b7e3a67f1f6342"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Container&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#6e66c6fe3b2fabebf2db862601b5ffbb">storein</a> (Container &amp;con)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute a query, and store the entire result set in an STL container.  <a href="#6e66c6fe3b2fabebf2db862601b5ffbb"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#73d7a8b96dad4f05b5047952907fef75">storein</a> (T &amp;con, <a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp;p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store template query results into a container.  <a href="#73d7a8b96dad4f05b5047952907fef75"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="298c9a98363662b3215c3b4c6743b437"></a><!-- doxytag: member="mysqlpp::Query::storein" ref="298c9a98363662b3215c3b4c6743b437" args="(std::vector&lt; T &gt; &amp;con, const SQLTypeAdapter &amp;s)" -->
template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#298c9a98363662b3215c3b4c6743b437">storein</a> (std::vector&lt; T &gt; &amp;con, const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of <a class="el" href="classmysqlpp_1_1Query.html#ef0903637280a12ca40b1d670ed502c0">storein_sequence()</a> for <code>std::vector</code>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="be095387a6e819007e98ab8e43fbf9d1"></a><!-- doxytag: member="mysqlpp::Query::storein" ref="be095387a6e819007e98ab8e43fbf9d1" args="(std::deque&lt; T &gt; &amp;con, const SQLTypeAdapter &amp;s)" -->
template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#be095387a6e819007e98ab8e43fbf9d1">storein</a> (std::deque&lt; T &gt; &amp;con, const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of <a class="el" href="classmysqlpp_1_1Query.html#ef0903637280a12ca40b1d670ed502c0">storein_sequence()</a> for <code>std::deque</code>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="7bb0ef4e8408cf187581a0f6aa95bc58"></a><!-- doxytag: member="mysqlpp::Query::storein" ref="7bb0ef4e8408cf187581a0f6aa95bc58" args="(std::list&lt; T &gt; &amp;con, const SQLTypeAdapter &amp;s)" -->
template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#7bb0ef4e8408cf187581a0f6aa95bc58">storein</a> (std::list&lt; T &gt; &amp;con, const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of <a class="el" href="classmysqlpp_1_1Query.html#ef0903637280a12ca40b1d670ed502c0">storein_sequence()</a> for <code>std::list</code>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="e0db02f594213a289d81df5f622429e1"></a><!-- doxytag: member="mysqlpp::Query::storein" ref="e0db02f594213a289d81df5f622429e1" args="(std::set&lt; T &gt; &amp;con, const SQLTypeAdapter &amp;s)" -->
template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#e0db02f594213a289d81df5f622429e1">storein</a> (std::set&lt; T &gt; &amp;con, const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of <a class="el" href="classmysqlpp_1_1Query.html#002234020d65383e07b4351177e1c368">storein_set()</a> for <code>std::set</code>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="9dd59f745232b98753fc11c57a139312"></a><!-- doxytag: member="mysqlpp::Query::storein" ref="9dd59f745232b98753fc11c57a139312" args="(std::multiset&lt; T &gt; &amp;con, const SQLTypeAdapter &amp;s)" -->
template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#9dd59f745232b98753fc11c57a139312">storein</a> (std::multiset&lt; T &gt; &amp;con, const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of <a class="el" href="classmysqlpp_1_1Query.html#002234020d65383e07b4351177e1c368">storein_set()</a> for <code>std::multiset</code>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classmysqlpp_1_1Query.html">Query</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#ad1349639bec2a1b5bb7d3bf34da3a37">update</a> (const T &amp;o, const T &amp;n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace an existing row's data with new data.  <a href="#ad1349639bec2a1b5bb7d3bf34da3a37"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classmysqlpp_1_1Query.html">Query</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#d38e23f66474ced0d153004ae07cea0c">insert</a> (const T &amp;v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a new row.  <a href="#d38e23f66474ced0d153004ae07cea0c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classmysqlpp_1_1Query.html">Query</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#394d3991e65ba58badafeb88cd220e7b">insert</a> (Iter first, Iter last)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert multiple new rows.  <a href="#394d3991e65ba58badafeb88cd220e7b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Iter, class InsertPolicy&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classmysqlpp_1_1Query.html">Query</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#6ddedfe4fd7f0a0007b0f0d85ae032d4">insertfrom</a> (Iter first, Iter last, InsertPolicy &amp;policy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert multiple new rows using an insert policy to control how the INSERT statements are created using items from an STL container.  <a href="#6ddedfe4fd7f0a0007b0f0d85ae032d4"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Iter, class InsertPolicy&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classmysqlpp_1_1Query.html">Query</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#0d0f803e18848b39d1c008272de69942">replacefrom</a> (Iter first, Iter last, InsertPolicy &amp;policy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace multiple new rows using an insert policy to control how the REPLACE statements are created using items from an STL container.  <a href="#0d0f803e18848b39d1c008272de69942"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classmysqlpp_1_1Query.html">Query</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#dbbce16ae80783fd00eef9c2319f1aff">replace</a> (const T &amp;v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert new row unless there is an existing row that matches on a unique index, in which case we replace it.  <a href="#dbbce16ae80783fd00eef9c2319f1aff"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classmysqlpp_1_1Query.html">Query</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#dce9dfa9f42dabd9c209258955824641">replace</a> (Iter first, Iter last)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert multiple new rows, or replace existing ones if there are existing rows that match on key fields.  <a href="#dce9dfa9f42dabd9c209258955824641"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1Query.html#622a5b10c49ab798f7f5481ff38a55d1">template_defaults</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The default template parameters.  <a href="#622a5b10c49ab798f7f5481ff38a55d1"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ccfe0b3b7df94fac0b2d30da93b72ed5"></a><!-- doxytag: member="mysqlpp::Query::SQLQueryParms" ref="ccfe0b3b7df94fac0b2d30da93b72ed5" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>SQLQueryParms</b></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A class for building and executing SQL queries. 
<p>
One does not generally create <a class="el" href="classmysqlpp_1_1Query.html">Query</a> objects directly. Instead, call <a class="el" href="classmysqlpp_1_1Connection.html#6954d437d52004915fbc96a0be79ab37">mysqlpp::Connection::query()</a> to get one tied to that connection.<p>
There are several ways to build and execute SQL queries with this class.<p>
The way most like other database libraries is to pass a SQL statement in either the form of a C or C++ string to one of the <a class="el" href="classmysqlpp_1_1Query.html#03ee1b9e393d88de946f5be804ea88cf">exec*(), </a> <a class="el" href="classmysqlpp_1_1Query.html#16c800e645429d558f4295065b1aed73">store*(), </a> or <a class="el" href="classmysqlpp_1_1Query.html#8538e92f55a5536bbf7704d27151ed87">use()</a> methods. The query is executed immediately, and any results returned.<p>
For more complicated queries, it's often more convenient to build up the query string over several C++ statements using Query's stream interface. It works like any other C++ stream (<code>std::cout</code>, <code>std::ostringstream</code>, etc.) in that you can just insert things into the stream, building the query up piece by piece. When the query string is complete, you call the overloaded version of <a class="el" href="classmysqlpp_1_1Query.html#03ee1b9e393d88de946f5be804ea88cf">exec*(), </a> <a class="el" href="classmysqlpp_1_1Query.html#16c800e645429d558f4295065b1aed73">store*(), </a> or <a class="el" href="classmysqlpp_1_1Query.html#8538e92f55a5536bbf7704d27151ed87">use() </a> takes no parameters, which executes the built query and returns any results.<p>
If you are using the library's Specialized SQL Structures feature, <a class="el" href="classmysqlpp_1_1Query.html">Query</a> has several special functions for generating common SQL queries from those structures. For instance, it offers the <a class="el" href="classmysqlpp_1_1Query.html#d38e23f66474ced0d153004ae07cea0c">insert() </a> method, which builds an INSERT query to add the contents of the SSQLS to the database. As with the stream interface, these methods only build the query string; call one of the parameterless methods mentioned previously to actually execute the query.<p>
Finally, you can build "template queries". This is something like C's <code>printf()</code> function, in that you insert a specially-formatted query string into the object which contains placeholders for data. You call the <a class="el" href="classmysqlpp_1_1Query.html#5bfc86346581917cb833ed55ccd4d5b8">parse()</a> method to tell the <a class="el" href="classmysqlpp_1_1Query.html">Query</a> object that the query string contains placeholders. Having done that, you call one of the the many <a class="el" href="classmysqlpp_1_1Query.html#f2cc737d916e4e1c9fd0392316e5415c">exec*(), </a> <a class="el" href="classmysqlpp_1_1Query.html#4531cbffbb15c003ff35c3bbbd3b4397">store*(), </a> or <a class="el" href="classmysqlpp_1_1Query.html#fe90361bc4f17f78c11857d32538dabe">use() </a> overloads that take <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> objects. There are 25 of each by default, differing only in the number of STA objects they take. (See <code>lib/querydef.pl</code> if you need to change the limit, or <code>examples/tquery2.cpp</code> for a way around it that doesn't require changing the library.) Only the version taking a single STA object is documented below, as to document all of them would just be repetitive. For each <a class="el" href="classmysqlpp_1_1Query.html">Query</a> method that takes a single STA object, there's a good chance there's a set of undocumented overloads that take more of them for the purpose of filling out a template query.<p>
See the user manual for more details about these options. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="6c6cbae18ebcb31b6d44e7784d5a3daa"></a><!-- doxytag: member="mysqlpp::Query::Query" ref="6c6cbae18ebcb31b6d44e7784d5a3daa" args="(Connection *c, bool te=true, const char *qstr=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mysqlpp::Query::Query           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1Connection.html">Connection</a> *&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>te</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>qstr</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new query object attached to a connection. 
<p>
This is the constructor used by <a class="el" href="classmysqlpp_1_1Connection.html#6954d437d52004915fbc96a0be79ab37">mysqlpp::Connection::query()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>connection the finished query should be sent out on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>te</em>&nbsp;</td><td>if true, throw exceptions on errors </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>qstr</em>&nbsp;</td><td>an optional initial query string </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="936b1062bb31b3428ead059a26590b6b"></a><!-- doxytag: member="mysqlpp::Query::Query" ref="936b1062bb31b3428ead059a26590b6b" args="(const Query &amp;q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mysqlpp::Query::Query           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1Query.html">Query</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new query object as a copy of another. 
<p>
This is <b>not</b> a traditional copy ctor! Its only purpose is to make it possible to assign the return of <a class="el" href="classmysqlpp_1_1Connection.html#6954d437d52004915fbc96a0be79ab37">Connection::query()</a> to an empty <a class="el" href="classmysqlpp_1_1Query.html">Query</a> object. In particular, the stream buffer and template query stuff will be empty in the copy, regardless of what values they have in the original. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="3acf442e091bdfb5344cbe9990f05f3b"></a><!-- doxytag: member="mysqlpp::Query::errnum" ref="3acf442e091bdfb5344cbe9990f05f3b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mysqlpp::Query::errnum           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the last error number that was set. 
<p>
This just delegates to <a class="el" href="classmysqlpp_1_1Connection.html#3cb1bf601b19dbb87b36bed4590f4214">Connection::errnum()</a>. <a class="el" href="classmysqlpp_1_1Query.html">Query</a> has nothing extra to say, so use either, as makes sense in your program. 
</div>
</div><p>
<a class="anchor" name="24ddaff8ae037c56c1a5aceda34e89c8"></a><!-- doxytag: member="mysqlpp::Query::error" ref="24ddaff8ae037c56c1a5aceda34e89c8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * mysqlpp::Query::error           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the last error message that was set. 
<p>
This just delegates to <a class="el" href="classmysqlpp_1_1Connection.html#73c67c9a4d4c77fcf2c7a98555542c8a">Connection::error()</a>. <a class="el" href="classmysqlpp_1_1Query.html">Query</a> has nothing extra to say, so use either, as makes sense in your program. 
</div>
</div><p>
<a class="anchor" name="b9061afbd8f1c03751b92b8ec6ba0de9"></a><!-- doxytag: member="mysqlpp::Query::escape_string" ref="b9061afbd8f1c03751b92b8ec6ba0de9" args="(char *escaped, const char *original, size_t length) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mysqlpp::Query::escape_string           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>escaped</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a SQL-escaped version of the given character buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>escaped</em>&nbsp;</td><td>character buffer to hold escaped version; must point to at least (length * 2 + 1) bytes </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>original</em>&nbsp;</td><td>pointer to the character buffer to escape </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>number of characters to escape</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>number</em>&nbsp;</td><td>of characters placed in escaped</td></tr>
  </table>
</dl>
<a class="el" href="classmysqlpp_1_1DBDriver.html">DBDriver</a> provides two versions of this method and <a class="el" href="classmysqlpp_1_1Query.html#dc7d259cbf78f1e418b7ad12751c5342">Query::escape_string()</a> calls the appropriate one based on whether or not a database connection is available. If the connection is available, it can call the <a class="el" href="classmysqlpp_1_1DBDriver.html#69881b0fab7f7d10c1d1adc7aacbbd6a">DBDriver::escape_string()</a> method. If there is no database connection available (normally only in testing), then <a class="el" href="classmysqlpp_1_1DBDriver.html">DBDriver</a> provides a static version of the function that doesn't use a database connection.<p>
<dl compact><dt><b>See also:</b></dt><dd>comments for <a class="el" href="classmysqlpp_1_1DBDriver.html#69881b0fab7f7d10c1d1adc7aacbbd6a">DBDriver::escape_string(char*, const char*, size_t)</a>, <a class="el" href="classmysqlpp_1_1DBDriver.html#2a404051fc2cc55b9e1f41cfe47190f3">DBDriver::escape_string_no_conn(char*, const char*, size_t)</a> for further details. </dd></dl>

</div>
</div><p>
<a class="anchor" name="dc7d259cbf78f1e418b7ad12751c5342"></a><!-- doxytag: member="mysqlpp::Query::escape_string" ref="dc7d259cbf78f1e418b7ad12751c5342" args="(std::string *ps, const char *original=0, size_t length=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mysqlpp::Query::escape_string           </td>
          <td>(</td>
          <td class="paramtype">std::string *&nbsp;</td>
          <td class="paramname"> <em>ps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>original</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a SQL-escaped version of a character buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ps</em>&nbsp;</td><td>pointer to C++ string to hold escaped version; if original is 0, also holds the original data to be escaped </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>original</em>&nbsp;</td><td>if given, pointer to the character buffer to escape instead of contents of *ps </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>if both this and original are given, number of characters to escape instead of ps-&gt;length()</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>number</em>&nbsp;</td><td>of characters placed in *ps</td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd>comments for escape_string(char*, const char*, size_t) and <a class="el" href="classmysqlpp_1_1DBDriver.html#64b30d25d02719ffc22f9b3ba92cdd89">DBDriver::escape_string(std::string*, const char *, size_t)</a> for further details. </dd></dl>

</div>
</div><p>
<a class="anchor" name="985acb52d0a988d1800c8fc4f4c5dc06"></a><!-- doxytag: member="mysqlpp::Query::exec" ref="985acb52d0a988d1800c8fc4f4c5dc06" args="(const std::string &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mysqlpp::Query::exec           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Execute a query. 
<p>
Same as <a class="el" href="classmysqlpp_1_1Query.html#03ee1b9e393d88de946f5be804ea88cf">execute()</a>, except that it only returns a flag indicating whether the query succeeded or not. It is basically a thin wrapper around the C API function <code>mysql_real_query()</code>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>the query to execute</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>true if query was executed successfully</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classmysqlpp_1_1Query.html#03ee1b9e393d88de946f5be804ea88cf">execute()</a>, <a class="el" href="classmysqlpp_1_1Query.html#16c800e645429d558f4295065b1aed73">store()</a>, <a class="el" href="classmysqlpp_1_1Query.html#6e66c6fe3b2fabebf2db862601b5ffbb">storein()</a>, and <a class="el" href="classmysqlpp_1_1Query.html#8538e92f55a5536bbf7704d27151ed87">use()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="23057cc385f9645d7d7ef00aecc2c8ba"></a><!-- doxytag: member="mysqlpp::Query::exec" ref="23057cc385f9645d7d7ef00aecc2c8ba" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mysqlpp::Query::exec           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Execute a built-up query. 
<p>
Same as <a class="el" href="classmysqlpp_1_1Query.html#23057cc385f9645d7d7ef00aecc2c8ba">exec()</a>, except that it uses the query string built up within the query object already instead of accepting a query string from the caller.<p>
<dl compact><dt><b>Returns:</b></dt><dd>true if query was executed successfully</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classmysqlpp_1_1Query.html#985acb52d0a988d1800c8fc4f4c5dc06">exec(const std::string&amp; str)</a>, <a class="el" href="classmysqlpp_1_1Query.html#03ee1b9e393d88de946f5be804ea88cf">execute()</a>, <a class="el" href="classmysqlpp_1_1Query.html#16c800e645429d558f4295065b1aed73">store()</a>, <a class="el" href="classmysqlpp_1_1Query.html#6e66c6fe3b2fabebf2db862601b5ffbb">storein()</a>, and <a class="el" href="classmysqlpp_1_1Query.html#8538e92f55a5536bbf7704d27151ed87">use()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="1faab5676c797dac619c6c98dc264e3c"></a><!-- doxytag: member="mysqlpp::Query::execute" ref="1faab5676c797dac619c6c98dc264e3c" args="(const char *str, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1SimpleResult.html">SimpleResult</a> mysqlpp::Query::execute           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Execute query in a known-length string of characters. This can include null characters. 
<p>
Executes the query immediately, and returns the results. 
</div>
</div><p>
<a class="anchor" name="f2cc737d916e4e1c9fd0392316e5415c"></a><!-- doxytag: member="mysqlpp::Query::execute" ref="f2cc737d916e4e1c9fd0392316e5415c" args="(const SQLTypeAdapter &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1SimpleResult.html">SimpleResult</a> mysqlpp::Query::execute           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Execute a query that returns no rows. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>if this object is set up as a template query, this is the value to substitute for the first template query parameter; else, it is the SQL query string to execute</td></tr>
  </table>
</dl>
Because <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> can be initialized from either a C string or a C++ string, this overload accepts query strings in either form. Beware, <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> also accepts many other data types (this is its <em>raison</em> <em>d'etre</em>), so it will let you write code that compiles but results in bogus SQL queries.<p>
To support template queries, there many more overloads of this type (25 total, by default; see <code>lib/querydef.pl</code>), each taking one more <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> object than the previous one. See the template query overview above for more about this topic. 
</div>
</div><p>
<a class="anchor" name="af36ce2e47a62fae2cc507a7750d1ecd"></a><!-- doxytag: member="mysqlpp::Query::execute" ref="af36ce2e47a62fae2cc507a7750d1ecd" args="(SQLQueryParms &amp;p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1SimpleResult.html">SimpleResult</a> mysqlpp::Query::execute           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Execute template query using given parameters. 
<p>
This method should only be used by code that doesn't know, at compile time, how many parameters it will have. This is useful within the library, and also for code that builds template queries dynamically, at run time.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>parameters to use in the template query. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="03ee1b9e393d88de946f5be804ea88cf"></a><!-- doxytag: member="mysqlpp::Query::execute" ref="03ee1b9e393d88de946f5be804ea88cf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1SimpleResult.html">SimpleResult</a> mysqlpp::Query::execute           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Execute built-up query. 
<p>
Use one of the <a class="el" href="classmysqlpp_1_1Query.html#03ee1b9e393d88de946f5be804ea88cf">execute()</a> overloads if you don't expect the server to return a result set. For instance, a DELETE query. The returned <a class="el" href="classmysqlpp_1_1SimpleResult.html">SimpleResult</a> object contains status information from the server, such as whether the query succeeded, and if so how many rows were affected.<p>
This overloaded version of <a class="el" href="classmysqlpp_1_1Query.html#03ee1b9e393d88de946f5be804ea88cf">execute()</a> simply executes the query that you have built up in the object in some way. (For instance, via the <a class="el" href="classmysqlpp_1_1Query.html#d38e23f66474ced0d153004ae07cea0c">insert()</a> method, or by using the object's stream interface.)<p>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="classmysqlpp_1_1SimpleResult.html">SimpleResult</a> status information about the query</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classmysqlpp_1_1Query.html#23057cc385f9645d7d7ef00aecc2c8ba">exec()</a>, <a class="el" href="classmysqlpp_1_1Query.html#16c800e645429d558f4295065b1aed73">store()</a>, <a class="el" href="classmysqlpp_1_1Query.html#6e66c6fe3b2fabebf2db862601b5ffbb">storein()</a>, and <a class="el" href="classmysqlpp_1_1Query.html#8538e92f55a5536bbf7704d27151ed87">use()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="0143fa17dcc54047c9a72678f0df042e"></a><!-- doxytag: member="mysqlpp::Query::for_each" ref="0143fa17dcc54047c9a72678f0df042e" args="(const SSQLS &amp;ssqls, Function fn)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SSQLS, typename Function&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Function mysqlpp::Query::for_each           </td>
          <td>(</td>
          <td class="paramtype">const SSQLS &amp;&nbsp;</td>
          <td class="paramname"> <em>ssqls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function&nbsp;</td>
          <td class="paramname"> <em>fn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Run a functor for every row in a table. 
<p>
Just like <a class="el" href="classmysqlpp_1_1Query.html#70a1c1be5272b8ee06c8fa0b20172423">for_each(Function)</a>, except that it builds a "select * from TABLE" query using the SQL table name from the SSQLS instance you pass.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ssqls</em>&nbsp;</td><td>the SSQLS instance to get a table name from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fn</em>&nbsp;</td><td>the functor called for each row</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>a copy of the passed functor </dd></dl>

</div>
</div><p>
<a class="anchor" name="70a1c1be5272b8ee06c8fa0b20172423"></a><!-- doxytag: member="mysqlpp::Query::for_each" ref="70a1c1be5272b8ee06c8fa0b20172423" args="(Function fn)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Function mysqlpp::Query::for_each           </td>
          <td>(</td>
          <td class="paramtype">Function&nbsp;</td>
          <td class="paramname"> <em>fn</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Execute the query, and call a functor for each returned row. 
<p>
Just like <a class="el" href="classmysqlpp_1_1Query.html#806794716f7f97b1f76ccdc6c3f548d0">for_each(const SQLTypeAdapter&amp;, Function)</a>, but it uses the query string held by the <a class="el" href="classmysqlpp_1_1Query.html">Query</a> object already<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fn</em>&nbsp;</td><td>the functor called for each row </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>a copy of the passed functor </dd></dl>

</div>
</div><p>
<a class="anchor" name="806794716f7f97b1f76ccdc6c3f548d0"></a><!-- doxytag: member="mysqlpp::Query::for_each" ref="806794716f7f97b1f76ccdc6c3f548d0" args="(const SQLTypeAdapter &amp;query, Function fn)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Function mysqlpp::Query::for_each           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function&nbsp;</td>
          <td class="paramname"> <em>fn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Execute a query, and call a functor for each returned row. 
<p>
This method wraps a <a class="el" href="classmysqlpp_1_1Query.html#8538e92f55a5536bbf7704d27151ed87">use()</a> query, calling the given functor for every returned row. It is analogous to STL's <a class="el" href="classmysqlpp_1_1Query.html#806794716f7f97b1f76ccdc6c3f548d0">for_each()</a> algorithm, but instead of iterating over some range within a container, it iterates over a result set produced by a query.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>query</em>&nbsp;</td><td>the query string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fn</em>&nbsp;</td><td>the functor called for each row </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>a copy of the passed functor </dd></dl>

</div>
</div><p>
<a class="anchor" name="394d3991e65ba58badafeb88cd220e7b"></a><!-- doxytag: member="mysqlpp::Query::insert" ref="394d3991e65ba58badafeb88cd220e7b" args="(Iter first, Iter last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1Query.html">Query</a>&amp; mysqlpp::Query::insert           </td>
          <td>(</td>
          <td class="paramtype">Iter&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert multiple new rows. 
<p>
Builds an INSERT SQL query using items from a range within an STL container. Insert the entire contents of the container by using the begin() and end() iterators of the container as parameters to this function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>iterator pointing to first element in range to insert </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>iterator pointing to one past the last element to insert</td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classmysqlpp_1_1Query.html#6ddedfe4fd7f0a0007b0f0d85ae032d4">insertfrom()</a>, <a class="el" href="classmysqlpp_1_1Query.html#dbbce16ae80783fd00eef9c2319f1aff">replace()</a>, <a class="el" href="classmysqlpp_1_1Query.html#ad1349639bec2a1b5bb7d3bf34da3a37">update()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="d38e23f66474ced0d153004ae07cea0c"></a><!-- doxytag: member="mysqlpp::Query::insert" ref="d38e23f66474ced0d153004ae07cea0c" args="(const T &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1Query.html">Query</a>&amp; mysqlpp::Query::insert           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert a new row. 
<p>
This function builds an INSERT SQL query. One uses it with MySQL++'s Specialized SQL Structures mechanism.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>new row</td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classmysqlpp_1_1Query.html#dbbce16ae80783fd00eef9c2319f1aff">replace()</a>, <a class="el" href="classmysqlpp_1_1Query.html#ad1349639bec2a1b5bb7d3bf34da3a37">update()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="a15198c894157a099154be69201b5baf"></a><!-- doxytag: member="mysqlpp::Query::insert_id" ref="a15198c894157a099154be69201b5baf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulonglong mysqlpp::Query::insert_id           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get ID generated for an AUTO_INCREMENT column in the previous INSERT query. 
<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>if the previous query did not generate an ID. Use the SQL function LAST_INSERT_ID() if you need the last ID generated by any query, not just the previous one. This applies to stored procedure calls because this function returns the ID generated by the last query, which was a CALL statement, and CALL doesn't generate IDs. You need to use LAST_INSERT_ID() to get the ID in this case. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6ddedfe4fd7f0a0007b0f0d85ae032d4"></a><!-- doxytag: member="mysqlpp::Query::insertfrom" ref="6ddedfe4fd7f0a0007b0f0d85ae032d4" args="(Iter first, Iter last, InsertPolicy &amp;policy)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iter, class InsertPolicy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1Query.html">Query</a>&amp; mysqlpp::Query::insertfrom           </td>
          <td>(</td>
          <td class="paramtype">Iter&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InsertPolicy &amp;&nbsp;</td>
          <td class="paramname"> <em>policy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert multiple new rows using an insert policy to control how the INSERT statements are created using items from an STL container. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>iterator pointing to first element in range to insert </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>iterator pointing to one past the last element to insert </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>policy</em>&nbsp;</td><td>insert policy object, see <a class="el" href="insertpolicy_8h.html">insertpolicy.h</a> for details</td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classmysqlpp_1_1Query.html#d38e23f66474ced0d153004ae07cea0c">insert()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="eeaff6b3fb94ff4bcad4046a833ee2ed"></a><!-- doxytag: member="mysqlpp::Query::more_results" ref="eeaff6b3fb94ff4bcad4046a833ee2ed" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mysqlpp::Query::more_results           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return whether more results are waiting for a multi-query or stored procedure response. 
<p>
If this function returns true, you must call <a class="el" href="classmysqlpp_1_1Query.html#0e22c60aa550675b5e89ab9bbaea7f8e">store_next()</a> to fetch the next result set before you can execute more queries.<p>
Wraps mysql_more_results() in the MySQL C API. That function only exists in MySQL v4.1 and higher. Therefore, this function always returns false when built against older API libraries.<p>
<dl compact><dt><b>Returns:</b></dt><dd>true if another result set exists </dd></dl>

</div>
</div><p>
<a class="anchor" name="9c2ff95a7cd013758cb1ad9984a7b74e"></a><!-- doxytag: member="mysqlpp::Query::operator void *" ref="9c2ff95a7cd013758cb1ad9984a7b74e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mysqlpp::Query::operator void *           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test whether the object has experienced an error condition. 
<p>
Allows for code constructs like this:<p>
<div class="fragment"><pre class="fragment">







        <span class="comment">/// </span>
</pre></div><p>
This method returns false if either the <a class="el" href="classmysqlpp_1_1Query.html">Query</a> object or its associated <a class="el" href="classmysqlpp_1_1Connection.html">Connection</a> object has seen an error condition since the last operation. 
</div>
</div><p>
<a class="anchor" name="dc5e3d5604dbe48cda5d8d2e64d896f4"></a><!-- doxytag: member="mysqlpp::Query::operator!" ref="dc5e3d5604dbe48cda5d8d2e64d896f4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mysqlpp::Query::operator!           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the query object is not in a bad state. 
<p>
This just returns the opposite of <a class="el" href="classmysqlpp_1_1Query.html#9c2ff95a7cd013758cb1ad9984a7b74e">operator void*()</a>, and is required only because basic_ios defines it, so we have to override it to get Query-specific behavior in code like this:<p>
<div class="fragment"><pre class="fragment"> <span class="keywordflow">if</span> (!query) ... 
</pre></div> 
</div>
</div><p>
<a class="anchor" name="75982ff4f3b5fe603ee6041ed64172ce"></a><!-- doxytag: member="mysqlpp::Query::operator=" ref="75982ff4f3b5fe603ee6041ed64172ce" args="(const Query &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1Query.html">Query</a> &amp; mysqlpp::Query::operator=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1Query.html">Query</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assign another query's state to this object. 
<p>
The same caveats apply to this operator as apply to the copy ctor. 
</div>
</div><p>
<a class="anchor" name="5bfc86346581917cb833ed55ccd4d5b8"></a><!-- doxytag: member="mysqlpp::Query::parse" ref="5bfc86346581917cb833ed55ccd4d5b8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mysqlpp::Query::parse           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Treat the contents of the query string as a template query. 
<p>
This method sets up the internal structures used by all of the other members that accept template query parameters. See the "Template Queries" chapter in the user manual for more information. 
</div>
</div><p>
<a class="anchor" name="dce9dfa9f42dabd9c209258955824641"></a><!-- doxytag: member="mysqlpp::Query::replace" ref="dce9dfa9f42dabd9c209258955824641" args="(Iter first, Iter last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1Query.html">Query</a>&amp; mysqlpp::Query::replace           </td>
          <td>(</td>
          <td class="paramtype">Iter&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert multiple new rows, or replace existing ones if there are existing rows that match on key fields. 
<p>
Builds a REPLACE SQL query using items from a range within an STL container. Insert the entire contents of the container by using the begin() and end() iterators of the container as parameters to this function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>iterator pointing to first element in range to insert/replace </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>iterator pointing to one past the last element to insert/replace</td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classmysqlpp_1_1Query.html#6ddedfe4fd7f0a0007b0f0d85ae032d4">insertfrom()</a>, <a class="el" href="classmysqlpp_1_1Query.html#dbbce16ae80783fd00eef9c2319f1aff">replace()</a>, <a class="el" href="classmysqlpp_1_1Query.html#ad1349639bec2a1b5bb7d3bf34da3a37">update()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="dbbce16ae80783fd00eef9c2319f1aff"></a><!-- doxytag: member="mysqlpp::Query::replace" ref="dbbce16ae80783fd00eef9c2319f1aff" args="(const T &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1Query.html">Query</a>&amp; mysqlpp::Query::replace           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert new row unless there is an existing row that matches on a unique index, in which case we replace it. 
<p>
This function builds a REPLACE SQL query. One uses it with MySQL++'s Specialized SQL Structures mechanism.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>new row</td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classmysqlpp_1_1Query.html#d38e23f66474ced0d153004ae07cea0c">insert()</a>, <a class="el" href="classmysqlpp_1_1Query.html#ad1349639bec2a1b5bb7d3bf34da3a37">update()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="0d0f803e18848b39d1c008272de69942"></a><!-- doxytag: member="mysqlpp::Query::replacefrom" ref="0d0f803e18848b39d1c008272de69942" args="(Iter first, Iter last, InsertPolicy &amp;policy)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iter, class InsertPolicy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1Query.html">Query</a>&amp; mysqlpp::Query::replacefrom           </td>
          <td>(</td>
          <td class="paramtype">Iter&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InsertPolicy &amp;&nbsp;</td>
          <td class="paramname"> <em>policy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replace multiple new rows using an insert policy to control how the REPLACE statements are created using items from an STL container. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>iterator pointing to first element in range to replace </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>iterator pointing to one past the last element to replace </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>policy</em>&nbsp;</td><td>insert policy object, see <a class="el" href="insertpolicy_8h.html">insertpolicy.h</a> for details</td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classmysqlpp_1_1Query.html#d38e23f66474ced0d153004ae07cea0c">insert()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f12740e420c1d61b1d9c2995459a3ce0"></a><!-- doxytag: member="mysqlpp::Query::reset" ref="f12740e420c1d61b1d9c2995459a3ce0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mysqlpp::Query::reset           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reset the query object so that it can be reused. 
<p>
As of v3.0, <a class="el" href="classmysqlpp_1_1Query.html">Query</a> objects auto-reset upon query execution unless you've set it up for making template queries. (It can't auto-reset in that situation, because it would forget the template info.) Therefore, the only time you must call this is if you have a <a class="el" href="classmysqlpp_1_1Query.html">Query</a> object set up for making template queries, then want to build queries using one of the other methods. (Static strings, SSQLS, or the stream interface.) 
</div>
</div><p>
<a class="anchor" name="b02c4ab2f46159d9d45bfd2bbe57e2b4"></a><!-- doxytag: member="mysqlpp::Query::result_empty" ref="b02c4ab2f46159d9d45bfd2bbe57e2b4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mysqlpp::Query::result_empty           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the most recent result set was empty. 
<p>
Wraps <a class="el" href="classmysqlpp_1_1DBDriver.html#f56834aa1357f86141b9cdcccf4ff4ce">DBDriver::result_empty()</a> 
</div>
</div><p>
<a class="anchor" name="15f991f68505f9a35aed0a03932a1900"></a><!-- doxytag: member="mysqlpp::Query::store" ref="15f991f68505f9a35aed0a03932a1900" args="(const char *str, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1StoreQueryResult.html">StoreQueryResult</a> mysqlpp::Query::store           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Execute a query that can return rows, returning all of the rows in a random-access container. 
<p>
This overload is for situations where you have the query in a C string and have its length already. If you want to execute a query in a null-terminated C string or have the query string in some other form, you probably want to call <a class="el" href="classmysqlpp_1_1Query.html#4531cbffbb15c003ff35c3bbbd3b4397">store(const SQLTypeAdapter&amp;)</a> instead. <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> converts from plain C strings and other useful data types implicitly. 
</div>
</div><p>
<a class="anchor" name="4531cbffbb15c003ff35c3bbbd3b4397"></a><!-- doxytag: member="mysqlpp::Query::store" ref="4531cbffbb15c003ff35c3bbbd3b4397" args="(const SQLTypeAdapter &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1StoreQueryResult.html">StoreQueryResult</a> mysqlpp::Query::store           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Execute a query that can return rows, returning all of the rows in a random-access container. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>if this object is set up as a template query, this is the value to substitute for the first template query parameter; else, it is the SQL query string to execute</td></tr>
  </table>
</dl>
Because <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> can be initialized from either a C string or a C++ string, this overload accepts query strings in either form. Beware, <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> also accepts many other data types (this is its <em>raison</em> <em>d'etre</em>), so it will let you write code that compiles but results in bogus SQL queries.<p>
To support template queries, there many more overloads of this type (25 total, by default; see <code>lib/querydef.pl</code>), each taking one more <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> object than the previous one. See the template query overview above for more about this topic. 
</div>
</div><p>
<a class="anchor" name="2bcd3c940f936f38bd40396449007d80"></a><!-- doxytag: member="mysqlpp::Query::store" ref="2bcd3c940f936f38bd40396449007d80" args="(SQLQueryParms &amp;p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1StoreQueryResult.html">StoreQueryResult</a> mysqlpp::Query::store           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Store results from a template query using given parameters. 
<p>
This method should only be used by code that doesn't know, at compile time, how many parameters it will have. This is useful within the library, and also for code that builds template queries dynamically, at run time.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>parameters to use in the template query. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="16c800e645429d558f4295065b1aed73"></a><!-- doxytag: member="mysqlpp::Query::store" ref="16c800e645429d558f4295065b1aed73" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1StoreQueryResult.html">StoreQueryResult</a> mysqlpp::Query::store           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Execute a query that can return a result set. 
<p>
Use one of the <a class="el" href="classmysqlpp_1_1Query.html#16c800e645429d558f4295065b1aed73">store()</a> overloads to execute a query and retrieve the entire result set into memory. This is useful if you actually need all of the records at once, but if not, consider using one of the <a class="el" href="classmysqlpp_1_1Query.html#8538e92f55a5536bbf7704d27151ed87">use()</a> methods instead, which returns the results one at a time, so they don't allocate as much memory as <a class="el" href="classmysqlpp_1_1Query.html#16c800e645429d558f4295065b1aed73">store()</a>.<p>
You must use <a class="el" href="classmysqlpp_1_1Query.html#16c800e645429d558f4295065b1aed73">store()</a>, <a class="el" href="classmysqlpp_1_1Query.html#6e66c6fe3b2fabebf2db862601b5ffbb">storein()</a> or <a class="el" href="classmysqlpp_1_1Query.html#8538e92f55a5536bbf7704d27151ed87">use()</a> for <code>SELECT</code>, <code>SHOW</code>, <code>DESCRIBE</code> and <code>EXPLAIN</code> queries. You can use these functions with other query types, but since they don't return a result set, <a class="el" href="classmysqlpp_1_1Query.html#23057cc385f9645d7d7ef00aecc2c8ba">exec()</a> and <a class="el" href="classmysqlpp_1_1Query.html#03ee1b9e393d88de946f5be804ea88cf">execute()</a> are more efficient.<p>
The name of this method comes from the MySQL C API function it is implemented in terms of, <code>mysql_store_result()</code>.<p>
This function has the same set of overloads as <a class="el" href="classmysqlpp_1_1Query.html#03ee1b9e393d88de946f5be804ea88cf">execute()</a>.<p>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="classmysqlpp_1_1StoreQueryResult.html">StoreQueryResult</a> object containing entire result set</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classmysqlpp_1_1Query.html#23057cc385f9645d7d7ef00aecc2c8ba">exec()</a>, <a class="el" href="classmysqlpp_1_1Query.html#03ee1b9e393d88de946f5be804ea88cf">execute()</a>, <a class="el" href="classmysqlpp_1_1Query.html#6e66c6fe3b2fabebf2db862601b5ffbb">storein()</a>, and <a class="el" href="classmysqlpp_1_1Query.html#8538e92f55a5536bbf7704d27151ed87">use()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="c2ef13c964fc2d7f49fe38d7d8202ea4"></a><!-- doxytag: member="mysqlpp::Query::store_if" ref="c2ef13c964fc2d7f49fe38d7d8202ea4" args="(Sequence &amp;con, Function fn)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Sequence, typename Function&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Function mysqlpp::Query::store_if           </td>
          <td>(</td>
          <td class="paramtype">Sequence &amp;&nbsp;</td>
          <td class="paramname"> <em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function&nbsp;</td>
          <td class="paramname"> <em>fn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Execute the query, conditionally storing each row in a container. 
<p>
Just like <a class="el" href="classmysqlpp_1_1Query.html#e15ceb094cba199c3aad5ae99b77d12b">store_if(Sequence&amp;, const SQLTypeAdapter&amp;, Function)</a>, but it uses the query string held by the <a class="el" href="classmysqlpp_1_1Query.html">Query</a> object already<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>con</em>&nbsp;</td><td>the destination container; needs a push_back() method </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fn</em>&nbsp;</td><td>the functor called for each row </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>a copy of the passed functor </dd></dl>

</div>
</div><p>
<a class="anchor" name="04f4039dd658f7a4943cdb373543b4da"></a><!-- doxytag: member="mysqlpp::Query::store_if" ref="04f4039dd658f7a4943cdb373543b4da" args="(Sequence &amp;con, const SSQLS &amp;ssqls, Function fn)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Sequence, class SSQLS, typename Function&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Function mysqlpp::Query::store_if           </td>
          <td>(</td>
          <td class="paramtype">Sequence &amp;&nbsp;</td>
          <td class="paramname"> <em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SSQLS &amp;&nbsp;</td>
          <td class="paramname"> <em>ssqls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function&nbsp;</td>
          <td class="paramname"> <em>fn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pulls every row in a table, conditionally storing each one in a container. 
<p>
Just like <a class="el" href="classmysqlpp_1_1Query.html#e15ceb094cba199c3aad5ae99b77d12b">store_if(Sequence&amp;, const SQLTypeAdapter&amp;, Function)</a>, but it uses the SSQLS instance to construct a "select * from TABLE" query, using the table name field in the SSQLS.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>con</em>&nbsp;</td><td>the destination container; needs a push_back() method </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ssqls</em>&nbsp;</td><td>the SSQLS instance to get a table name from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fn</em>&nbsp;</td><td>the functor called for each row </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>a copy of the passed functor </dd></dl>

</div>
</div><p>
<a class="anchor" name="e15ceb094cba199c3aad5ae99b77d12b"></a><!-- doxytag: member="mysqlpp::Query::store_if" ref="e15ceb094cba199c3aad5ae99b77d12b" args="(Sequence &amp;con, const SQLTypeAdapter &amp;query, Function fn)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Sequence, typename Function&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Function mysqlpp::Query::store_if           </td>
          <td>(</td>
          <td class="paramtype">Sequence &amp;&nbsp;</td>
          <td class="paramname"> <em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function&nbsp;</td>
          <td class="paramname"> <em>fn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Execute a query, conditionally storing each row in a container. 
<p>
This method wraps a <a class="el" href="classmysqlpp_1_1Query.html#8538e92f55a5536bbf7704d27151ed87">use()</a> query, calling the given functor for every returned row, and storing the results in the given sequence container if the functor returns true.<p>
This is analogous to the STL copy_if() algorithm, except that the source rows come from a database query instead of another container. (copy_if() isn't a standard STL algorithm, but only due to an oversight by the standardization committee.) This fact may help you to remember the order of the parameters: the container is the destination, the query is the source, and the functor is the predicate; it's just like an STL algorithm.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>con</em>&nbsp;</td><td>the destination container; needs a push_back() method </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>query</em>&nbsp;</td><td>the query string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fn</em>&nbsp;</td><td>the functor called for each row </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>a copy of the passed functor </dd></dl>

</div>
</div><p>
<a class="anchor" name="0e22c60aa550675b5e89ab9bbaea7f8e"></a><!-- doxytag: member="mysqlpp::Query::store_next" ref="0e22c60aa550675b5e89ab9bbaea7f8e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1StoreQueryResult.html">StoreQueryResult</a> mysqlpp::Query::store_next           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return next result set, when processing a multi-query. 
<p>
There are two cases where you'd use this function instead of the regular <a class="el" href="classmysqlpp_1_1Query.html#16c800e645429d558f4295065b1aed73">store()</a> functions.<p>
First, when handling the result of executing multiple queries at once. (See <a href="http://dev.mysql.com/doc/mysql/en/c-api-multiple-queries.html" 
	>this page</a> in the MySQL documentation for details.)<p>
Second, when calling a stored procedure, MySQL can return the result as a set of results.<p>
In either case, you must consume all results before making another MySQL query, even if you don't care about the remaining results or result sets.<p>
As the MySQL documentation points out, you must set the MYSQL_OPTION_MULTI_STATEMENTS_ON flag on the connection in order to use this feature. See <a class="el" href="classmysqlpp_1_1Connection.html#266f69b0e8d9d588e8cc6c5a2a897b87">Connection::set_option()</a>.<p>
Multi-queries only exist in MySQL v4.1 and higher. Therefore, this function just wraps <a class="el" href="classmysqlpp_1_1Query.html#16c800e645429d558f4295065b1aed73">store()</a> when built against older API libraries.<p>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="classmysqlpp_1_1StoreQueryResult.html">StoreQueryResult</a> object containing the next result set. </dd></dl>

</div>
</div><p>
<a class="anchor" name="73d7a8b96dad4f05b5047952907fef75"></a><!-- doxytag: member="mysqlpp::Query::storein" ref="73d7a8b96dad4f05b5047952907fef75" args="(T &amp;con, SQLQueryParms &amp;p)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mysqlpp::Query::storein           </td>
          <td>(</td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Store template query results into a container. 
<p>
This method is not intended to be used directly. It is part of the call chain in processing calls to one of the many <a class="el" href="classmysqlpp_1_1Query.html#6e66c6fe3b2fabebf2db862601b5ffbb">storein()</a> overloads that take a container and one or more <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> parameters. 
</div>
</div><p>
<a class="anchor" name="6e66c6fe3b2fabebf2db862601b5ffbb"></a><!-- doxytag: member="mysqlpp::Query::storein" ref="6e66c6fe3b2fabebf2db862601b5ffbb" args="(Container &amp;con)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mysqlpp::Query::storein           </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&nbsp;</td>
          <td class="paramname"> <em>con</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Execute a query, and store the entire result set in an STL container. 
<p>
This is a set of specialized template functions that call either <a class="el" href="classmysqlpp_1_1Query.html#ef0903637280a12ca40b1d670ed502c0">storein_sequence()</a> or <a class="el" href="classmysqlpp_1_1Query.html#002234020d65383e07b4351177e1c368">storein_set()</a>, depending on the type of container you pass it. It understands <code>std::vector</code>, <code>deque</code>, <code>list</code>, <code>slist</code> (a common C++ library extension), <code>set</code>, and <code>multiset</code>.<p>
Like the functions it wraps, this is actually an overloaded set of functions. See the other functions' documentation for details.<p>
Use this function if you think you might someday switch your program from using a set-associative container to a sequence container for storing result sets, or vice versa.<p>
See <a class="el" href="classmysqlpp_1_1Query.html#23057cc385f9645d7d7ef00aecc2c8ba">exec()</a>, <a class="el" href="classmysqlpp_1_1Query.html#03ee1b9e393d88de946f5be804ea88cf">execute()</a>, <a class="el" href="classmysqlpp_1_1Query.html#16c800e645429d558f4295065b1aed73">store()</a>, and <a class="el" href="classmysqlpp_1_1Query.html#8538e92f55a5536bbf7704d27151ed87">use()</a> for alternative query execution mechanisms. 
</div>
</div><p>
<a class="anchor" name="d17b208852e71f054ed7e44f0ee56778"></a><!-- doxytag: member="mysqlpp::Query::storein_sequence" ref="d17b208852e71f054ed7e44f0ee56778" args="(Seq &amp;con, SQLQueryParms &amp;p)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Seq&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mysqlpp::Query::storein_sequence           </td>
          <td>(</td>
          <td class="paramtype">Seq &amp;&nbsp;</td>
          <td class="paramname"> <em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Execute template query using given parameters, storing the results in a sequence type container. 
<p>
This method should only be used by code that doesn't know, at compile time, how many parameters it will have. This is useful within the library, and also for code that builds template queries dynamically, at run time.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>con</em>&nbsp;</td><td>container that will receive the results </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>parameters to use in the template query. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2991cd00cec285d0ab5f8763de8fa677"></a><!-- doxytag: member="mysqlpp::Query::storein_sequence" ref="2991cd00cec285d0ab5f8763de8fa677" args="(Sequence &amp;con, const SQLTypeAdapter &amp;s)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Sequence&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mysqlpp::Query::storein_sequence           </td>
          <td>(</td>
          <td class="paramtype">Sequence &amp;&nbsp;</td>
          <td class="paramname"> <em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Executes a query, storing the result rows in an STL sequence container. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>con</em>&nbsp;</td><td>the container to store the results in</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>if <a class="el" href="classmysqlpp_1_1Query.html">Query</a> is set up as a template query, this is the value to substitute for the first template query parameter; else, the SQL query string</td></tr>
  </table>
</dl>
There many more overloads of this type (25 total, by default; see <code>lib/querydef.pl</code>), each taking one more <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> object than the previous one. See the template query overview above for more about this topic. 
</div>
</div><p>
<a class="anchor" name="ef0903637280a12ca40b1d670ed502c0"></a><!-- doxytag: member="mysqlpp::Query::storein_sequence" ref="ef0903637280a12ca40b1d670ed502c0" args="(Sequence &amp;con)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Sequence&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mysqlpp::Query::storein_sequence           </td>
          <td>(</td>
          <td class="paramtype">Sequence &amp;&nbsp;</td>
          <td class="paramname"> <em>con</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Execute a query, storing the result set in an STL sequence container. 
<p>
This function works much like <a class="el" href="classmysqlpp_1_1Query.html#16c800e645429d558f4295065b1aed73">store()</a> from the caller's perspective, because it returns the entire result set at once. It's actually implemented in terms of <a class="el" href="classmysqlpp_1_1Query.html#8538e92f55a5536bbf7704d27151ed87">use()</a>, however, so that memory for the result set doesn't need to be allocated twice.<p>
There are many overloads for this function, pretty much the same as for <a class="el" href="classmysqlpp_1_1Query.html#03ee1b9e393d88de946f5be804ea88cf">execute()</a>, except that there is a Container parameter at the front of the list. So, you can pass a container and a query string, or a container and template query parameters.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>con</em>&nbsp;</td><td>any STL sequence container, such as <code>std::vector</code> </td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classmysqlpp_1_1Query.html#23057cc385f9645d7d7ef00aecc2c8ba">exec()</a>, <a class="el" href="classmysqlpp_1_1Query.html#03ee1b9e393d88de946f5be804ea88cf">execute()</a>, <a class="el" href="classmysqlpp_1_1Query.html#16c800e645429d558f4295065b1aed73">store()</a>, and <a class="el" href="classmysqlpp_1_1Query.html#8538e92f55a5536bbf7704d27151ed87">use()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3ae482e561d54f7020b7e3a67f1f6342"></a><!-- doxytag: member="mysqlpp::Query::storein_set" ref="3ae482e561d54f7020b7e3a67f1f6342" args="(Set &amp;con, SQLQueryParms &amp;p)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mysqlpp::Query::storein_set           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1Set.html">Set</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Execute template query using given parameters, storing the results in a set type container. 
<p>
This method should only be used by code that doesn't know, at compile time, how many parameters it will have. This is useful within the library, and also for code that builds template queries dynamically, at run time.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>con</em>&nbsp;</td><td>container that will receive the results </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>parameters to use in the template query. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c930f8c58075c84786536ad586ae8ffe"></a><!-- doxytag: member="mysqlpp::Query::storein_set" ref="c930f8c58075c84786536ad586ae8ffe" args="(Set &amp;con, const SQLTypeAdapter &amp;s)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mysqlpp::Query::storein_set           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1Set.html">Set</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Executes a query, storing the result rows in an STL set-associative container. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>con</em>&nbsp;</td><td>the container to store the results in</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>if <a class="el" href="classmysqlpp_1_1Query.html">Query</a> is set up as a template query, this is the value to substitute for the first template query parameter; else, the SQL query string</td></tr>
  </table>
</dl>
There many more overloads of this type (25 total, by default; see <code>lib/querydef.pl</code>), each taking one more <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> object than the previous one. See the template query overview above for more about this topic. 
</div>
</div><p>
<a class="anchor" name="002234020d65383e07b4351177e1c368"></a><!-- doxytag: member="mysqlpp::Query::storein_set" ref="002234020d65383e07b4351177e1c368" args="(Set &amp;con)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mysqlpp::Query::storein_set           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1Set.html">Set</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>con</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Execute a query, storing the result set in an STL associative container. 
<p>
The same thing as <a class="el" href="classmysqlpp_1_1Query.html#ef0903637280a12ca40b1d670ed502c0">storein_sequence()</a>, except that it's used with associative STL containers, such as <code>std::set</code>. Other than that detail, that method's comments apply equally well to this one. 
</div>
</div><p>
<a class="anchor" name="c93d201c91a7e0b9056e8cac33a38f7d"></a><!-- doxytag: member="mysqlpp::Query::str" ref="c93d201c91a7e0b9056e8cac33a38f7d" args="(SQLQueryParms &amp;p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mysqlpp::Query::str           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get built query as a null-terminated C++ string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>template query parameters to use, overriding the ones this object holds, if any </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7fa8d56bd3d8a1bd3b5403665dbf6c8e"></a><!-- doxytag: member="mysqlpp::Query::str" ref="7fa8d56bd3d8a1bd3b5403665dbf6c8e" args="(const SQLTypeAdapter &amp;arg0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mysqlpp::Query::str           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>arg0</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get built query as a C++ string with template query parameter substitution. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>arg0</em>&nbsp;</td><td>the value to substitute for the first template query parameter; because <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> implicitly converts from many different data types, this method is very flexible in what it accepts as a parameter. You shouldn't have to use the <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> data type directly in your code.</td></tr>
  </table>
</dl>
There many more overloads of this type (25 total, by default; see <code>lib/querydef.pl</code>), each taking one more <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> object than the previous one. See the template query overview above for more about this topic. 
</div>
</div><p>
<a class="anchor" name="ad1349639bec2a1b5bb7d3bf34da3a37"></a><!-- doxytag: member="mysqlpp::Query::update" ref="ad1349639bec2a1b5bb7d3bf34da3a37" args="(const T &amp;o, const T &amp;n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1Query.html">Query</a>&amp; mysqlpp::Query::update           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replace an existing row's data with new data. 
<p>
This function builds an UPDATE SQL query using the new row data for the SET clause, and the old row data for the WHERE clause. One uses it with MySQL++'s Specialized SQL Structures mechanism.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>o</em>&nbsp;</td><td>old row </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>new row</td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classmysqlpp_1_1Query.html#d38e23f66474ced0d153004ae07cea0c">insert()</a>, <a class="el" href="classmysqlpp_1_1Query.html#dbbce16ae80783fd00eef9c2319f1aff">replace()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b00af2e285dbb32eb51de17e567d8b00"></a><!-- doxytag: member="mysqlpp::Query::use" ref="b00af2e285dbb32eb51de17e567d8b00" args="(const char *str, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1UseQueryResult.html">UseQueryResult</a> mysqlpp::Query::use           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Execute a query that can return rows, with access to the rows in sequence. 
<p>
This overload is for situations where you have the query in a C string and have its length already. If you want to execute a query in a null-terminated C string or have the query string in some other form, you probably want to call <a class="el" href="classmysqlpp_1_1Query.html#fe90361bc4f17f78c11857d32538dabe">use(const SQLTypeAdapter&amp;)</a> instead. <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> converts from plain C strings and other useful data types implicitly. 
</div>
</div><p>
<a class="anchor" name="fe90361bc4f17f78c11857d32538dabe"></a><!-- doxytag: member="mysqlpp::Query::use" ref="fe90361bc4f17f78c11857d32538dabe" args="(const SQLTypeAdapter &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1UseQueryResult.html">UseQueryResult</a> mysqlpp::Query::use           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Execute a query that can return rows, with access to the rows in sequence. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>if this object is set up as a template query, this is the value to substitute for the first template query parameter; else, it is the SQL query string to execute</td></tr>
  </table>
</dl>
Because <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> can be initialized from either a C string or a C++ string, this overload accepts query strings in either form. Beware, <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> also accepts many other data types (this is its <em>raison</em> <em>d'etre</em>), so it will let you write code that compiles but results in bogus SQL queries.<p>
To support template queries, there many more overloads of this type (25 total, by default; see <code>lib/querydef.pl</code>), each taking one more <a class="el" href="classmysqlpp_1_1SQLTypeAdapter.html">SQLTypeAdapter</a> object than the previous one. See the template query overview above for more about this topic. 
</div>
</div><p>
<a class="anchor" name="66040c8c0071b50b043e8031309f7852"></a><!-- doxytag: member="mysqlpp::Query::use" ref="66040c8c0071b50b043e8031309f7852" args="(SQLQueryParms &amp;p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1UseQueryResult.html">UseQueryResult</a> mysqlpp::Query::use           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Execute a template query that can return rows, with access to the rows in sequence. 
<p>
This method should only be used by code that doesn't know, at compile time, how many parameters it will have. This is useful within the library, and also for code that builds template queries dynamically, at run time.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>parameters to use in the template query. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8538e92f55a5536bbf7704d27151ed87"></a><!-- doxytag: member="mysqlpp::Query::use" ref="8538e92f55a5536bbf7704d27151ed87" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1UseQueryResult.html">UseQueryResult</a> mysqlpp::Query::use           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Execute a query that can return rows, with access to the rows in sequence. 
<p>
Use one of the <a class="el" href="classmysqlpp_1_1Query.html#8538e92f55a5536bbf7704d27151ed87">use()</a> overloads if memory efficiency is important. They return an object that can walk through the result records one by one, without fetching the entire result set from the server. This is superior to <a class="el" href="classmysqlpp_1_1Query.html#16c800e645429d558f4295065b1aed73">store()</a> when there are a large number of results; <a class="el" href="classmysqlpp_1_1Query.html#16c800e645429d558f4295065b1aed73">store()</a> would have to allocate a large block of memory to hold all those records, which could cause problems.<p>
A potential downside of this method is that MySQL database resources are tied up until the result set is completely consumed. Do your best to walk through the result set as expeditiously as possible.<p>
The name of this method comes from the MySQL C API function that initiates the retrieval process, <code>mysql_use_result()</code>. This method is implemented in terms of that function.<p>
This function has the same set of overloads as <a class="el" href="classmysqlpp_1_1Query.html#03ee1b9e393d88de946f5be804ea88cf">execute()</a>.<p>
<dl compact><dt><b>Returns:</b></dt><dd><a class="el" href="classmysqlpp_1_1UseQueryResult.html">UseQueryResult</a> object that can walk through result set serially</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classmysqlpp_1_1Query.html#23057cc385f9645d7d7ef00aecc2c8ba">exec()</a>, <a class="el" href="classmysqlpp_1_1Query.html#03ee1b9e393d88de946f5be804ea88cf">execute()</a>, <a class="el" href="classmysqlpp_1_1Query.html#16c800e645429d558f4295065b1aed73">store()</a> and <a class="el" href="classmysqlpp_1_1Query.html#6e66c6fe3b2fabebf2db862601b5ffbb">storein()</a> </dd></dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="622a5b10c49ab798f7f5481ff38a55d1"></a><!-- doxytag: member="mysqlpp::Query::template_defaults" ref="622a5b10c49ab798f7f5481ff38a55d1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> <a class="el" href="classmysqlpp_1_1Query.html#622a5b10c49ab798f7f5481ff38a55d1">mysqlpp::Query::template_defaults</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The default template parameters. 
<p>
Used for filling in parameterized queries. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="query_8h-source.html">query.h</a><li>query.cpp</ul>
<hr size="1"><address style="align: right;"><small>Generated on 10 Dec 2013 for MySQL++ by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
