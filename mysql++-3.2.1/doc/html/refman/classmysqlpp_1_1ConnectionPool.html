<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
	<title>MySQL++ Reference Manual</title>
	<meta http-equiv="Content-type" content="text/html;charset=iso-8859-1">
	<link href="doxygen.css" rel="stylesheet" type="text/css">
	<link href="refman.css" rel="stylesheet" type="text/css">
</head>
<body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<b>mysqlpp</b>::<a class="el" href="classmysqlpp_1_1ConnectionPool.html">ConnectionPool</a></div>
<h1>mysqlpp::ConnectionPool Class Reference</h1><!-- doxytag: class="mysqlpp::ConnectionPool" -->Manages a pool of connections for programs that need more than one <a class="el" href="classmysqlpp_1_1Connection.html">Connection</a> object at a time, but can't predict how many they need in advance.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="cpool_8h-source.html">cpool.h</a>&gt;</code>
<p>
Collaboration diagram for mysqlpp::ConnectionPool:<p><center><img src="classmysqlpp_1_1ConnectionPool__coll__graph.png" border="0" usemap="#mysqlpp_1_1ConnectionPool__coll__map" alt="Collaboration graph"></center>
<map name="mysqlpp_1_1ConnectionPool__coll__map">
<area href="classmysqlpp_1_1BeecryptMutex.html" shape="rect" coords="5,5,192,32" alt="">
</map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center><a href="classmysqlpp_1_1ConnectionPool-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cc1262db33d586284651825ff076a8d7"></a><!-- doxytag: member="mysqlpp::ConnectionPool::ConnectionPool" ref="cc1262db33d586284651825ff076a8d7" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1ConnectionPool.html#cc1262db33d586284651825ff076a8d7">ConnectionPool</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create empty pool. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1ConnectionPool.html#2cee954229416e24da07f5e208b35b09">~ConnectionPool</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy object.  <a href="#2cee954229416e24da07f5e208b35b09"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="264ea3fc4311c8bfd18e7d7b6103d124"></a><!-- doxytag: member="mysqlpp::ConnectionPool::empty" ref="264ea3fc4311c8bfd18e7d7b6103d124" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1ConnectionPool.html#264ea3fc4311c8bfd18e7d7b6103d124">empty</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if pool is empty. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classmysqlpp_1_1Connection.html">Connection</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1ConnectionPool.html#4f9844f2c57c9f51f1b5a2b8a996ee15">exchange</a> (const <a class="el" href="classmysqlpp_1_1Connection.html">Connection</a> *pc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a defective connection to the pool and get a new one back.  <a href="#4f9844f2c57c9f51f1b5a2b8a996ee15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classmysqlpp_1_1Connection.html">Connection</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1ConnectionPool.html#cbf56ee86ef66b3ebdf02adde5908776">grab</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Grab a free connection from the pool.  <a href="#cbf56ee86ef66b3ebdf02adde5908776"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1ConnectionPool.html#c51a7a63ce4d8825c3f7b05f4b8bfe68">release</a> (const <a class="el" href="classmysqlpp_1_1Connection.html">Connection</a> *pc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a connection to the pool.  <a href="#c51a7a63ce4d8825c3f7b05f4b8bfe68"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1ConnectionPool.html#ae75febe979da2d4a3335c46438f3d33">remove</a> (const <a class="el" href="classmysqlpp_1_1Connection.html">Connection</a> *pc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the given connection from the pool.  <a href="#ae75febe979da2d4a3335c46438f3d33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classmysqlpp_1_1Connection.html">Connection</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1ConnectionPool.html#ac4d50bb5c603efec4b8d7e0a3e8a164">safe_grab</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Grab a free connection from the pool, testing that it's connected before returning it.  <a href="#ac4d50bb5c603efec4b8d7e0a3e8a164"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c410ed5cb3032aed048fb3a275629654"></a><!-- doxytag: member="mysqlpp::ConnectionPool::shrink" ref="c410ed5cb3032aed048fb3a275629654" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1ConnectionPool.html#c410ed5cb3032aed048fb3a275629654">shrink</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove all unused connections from the pool. <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1ConnectionPool.html#981e1b1715de2daea9f6b10bdcbb5915">clear</a> (bool all=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drains the pool, freeing all allocated memory.  <a href="#981e1b1715de2daea9f6b10bdcbb5915"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classmysqlpp_1_1Connection.html">Connection</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1ConnectionPool.html#f755c7e11b92bbab0e88ab3e9c88f0fd">create</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new connection.  <a href="#f755c7e11b92bbab0e88ab3e9c88f0fd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1ConnectionPool.html#3dae30e24dd6967e4e427fa69dbc2105">destroy</a> (<a class="el" href="classmysqlpp_1_1Connection.html">Connection</a> *)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy a connection.  <a href="#3dae30e24dd6967e4e427fa69dbc2105"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1ConnectionPool.html#8a5ba414a5b02c48d64501c25b64a656">max_idle_time</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the maximum number of seconds a connection is able to remain idle before it is dropped.  <a href="#8a5ba414a5b02c48d64501c25b64a656"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3a42387a44afad4c3d3895ba89ded21d"></a><!-- doxytag: member="mysqlpp::ConnectionPool::size" ref="3a42387a44afad4c3d3895ba89ded21d" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmysqlpp_1_1ConnectionPool.html#3a42387a44afad4c3d3895ba89ded21d">size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current size of the internal connection pool. <br></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>ConnectionInfo</b></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Manages a pool of connections for programs that need more than one <a class="el" href="classmysqlpp_1_1Connection.html">Connection</a> object at a time, but can't predict how many they need in advance. 
<p>
This class is useful in programs that need to make multiple simultaneous queries on the database; this requires multiple <a class="el" href="classmysqlpp_1_1Connection.html">Connection</a> objects due to a hard limitation of the underlying C API. <a class="el" href="classmysqlpp_1_1Connection.html">Connection</a> pools are most useful in multithreaded programs, but it can be helpful to have one in a single-threaded program as well. Sometimes it's necessary to get more data from the server while in the middle of processing data from an earlier query; this requires multiple connections. Whether you use a pool or manage connections yourself is up to you, but realize that this class takes care of a lot of subtle details for you that aren't obvious.<p>
The pool's policy for connection reuse is to always return the <em>most</em> recently used connection that's not being used right now. This ensures that excess connections don't hang around any longer than they must. If the pool were to return the <em>least</em> recently used connection, it would be likely to result in a large pool of sparsely used connections because we'd keep resetting the last-used time of whichever connection is least recently used at that moment. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="2cee954229416e24da07f5e208b35b09"></a><!-- doxytag: member="mysqlpp::ConnectionPool::~ConnectionPool" ref="2cee954229416e24da07f5e208b35b09" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual mysqlpp::ConnectionPool::~ConnectionPool           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroy object. 
<p>
If the pool raises an assertion on destruction, it means our subclass isn't calling <a class="el" href="classmysqlpp_1_1ConnectionPool.html#981e1b1715de2daea9f6b10bdcbb5915">clear()</a> in its dtor as it should. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="981e1b1715de2daea9f6b10bdcbb5915"></a><!-- doxytag: member="mysqlpp::ConnectionPool::clear" ref="981e1b1715de2daea9f6b10bdcbb5915" args="(bool all=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mysqlpp::ConnectionPool::clear           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>all</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Drains the pool, freeing all allocated memory. 
<p>
A derived class must call this in its dtor to avoid leaking all <a class="el" href="classmysqlpp_1_1Connection.html">Connection</a> objects still in existence. We can't do it up at this level because this class's dtor can't call our subclass's <a class="el" href="classmysqlpp_1_1ConnectionPool.html#3dae30e24dd6967e4e427fa69dbc2105">destroy()</a> method.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>all</em>&nbsp;</td><td>if true, remove all connections, even those in use </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f755c7e11b92bbab0e88ab3e9c88f0fd"></a><!-- doxytag: member="mysqlpp::ConnectionPool::create" ref="f755c7e11b92bbab0e88ab3e9c88f0fd" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmysqlpp_1_1Connection.html">Connection</a>* mysqlpp::ConnectionPool::create           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new connection. 
<p>
Subclasses must override this.<p>
Essentially, this method lets your code tell <a class="el" href="classmysqlpp_1_1ConnectionPool.html">ConnectionPool</a> what server to connect to, what login parameters to use, what connection options to enable, etc. <a class="el" href="classmysqlpp_1_1ConnectionPool.html">ConnectionPool</a> can't know any of this without your help.<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>connected <a class="el" href="classmysqlpp_1_1Connection.html">Connection</a> object </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3dae30e24dd6967e4e427fa69dbc2105"></a><!-- doxytag: member="mysqlpp::ConnectionPool::destroy" ref="3dae30e24dd6967e4e427fa69dbc2105" args="(Connection *)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mysqlpp::ConnectionPool::destroy           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmysqlpp_1_1Connection.html">Connection</a> *&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroy a connection. 
<p>
Subclasses must override this.<p>
This is for destroying the objects returned by <a class="el" href="classmysqlpp_1_1ConnectionPool.html#f755c7e11b92bbab0e88ab3e9c88f0fd">create()</a>. Because we can't know what the derived class did to create the connection we can't reliably know how to destroy it. 
</div>
</div><p>
<a class="anchor" name="4f9844f2c57c9f51f1b5a2b8a996ee15"></a><!-- doxytag: member="mysqlpp::ConnectionPool::exchange" ref="4f9844f2c57c9f51f1b5a2b8a996ee15" args="(const Connection *pc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1Connection.html">Connection</a> * mysqlpp::ConnectionPool::exchange           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1Connection.html">Connection</a> *&nbsp;</td>
          <td class="paramname"> <em>pc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a defective connection to the pool and get a new one back. 
<p>
Call this on receiving a <a class="el" href="classmysqlpp_1_1BadQuery.html">BadQuery</a> exception, with errnum() equal to CR_SERVER_GONE_ERROR. It means the server was restarted or otherwise dropped your connection to it, so the <a class="el" href="classmysqlpp_1_1Connection.html">Connection</a> object is no longer usable. You can avoid the need to use this by setting the <a class="el" href="classmysqlpp_1_1ReconnectOption.html">ReconnectOption</a> in your <a class="el" href="classmysqlpp_1_1ConnectionPool.html#cbf56ee86ef66b3ebdf02adde5908776">grab()</a> override, but perhaps there are other reasons to need to exchange a bad connection for a good one.<p>
This function wraps <a class="el" href="classmysqlpp_1_1ConnectionPool.html#cbf56ee86ef66b3ebdf02adde5908776">grab()</a>, not <a class="el" href="classmysqlpp_1_1ConnectionPool.html#ac4d50bb5c603efec4b8d7e0a3e8a164">safe_grab()</a>, even though that could return another dead connection. The assumption is that if your code is smart enough to detect one bad connection, it should be smart enough to detect a whole string of them. Worst case, the whole pool is bad -- remote server went away -- and we have to empty the pool and start re-filling it.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pc</em>&nbsp;</td><td>pointer to a <a class="el" href="classmysqlpp_1_1Connection.html">Connection</a> object to be returned to the pool and marked as unused.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>pointer to a different <a class="el" href="classmysqlpp_1_1Connection.html">Connection</a> object; not guaranteed to still be connected! </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="cbf56ee86ef66b3ebdf02adde5908776"></a><!-- doxytag: member="mysqlpp::ConnectionPool::grab" ref="cbf56ee86ef66b3ebdf02adde5908776" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1Connection.html">Connection</a> * mysqlpp::ConnectionPool::grab           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Grab a free connection from the pool. 
<p>
This method creates a new connection if an unused one doesn't exist, and destroys any that have remained unused for too long. If there is more than one free connection, we return the most recently used one; this allows older connections to die off over time when the caller's need for connections decreases.<p>
Do not delete the returned pointer. This object manages the lifetime of connection objects it creates.<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>pointer to the connection </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8a5ba414a5b02c48d64501c25b64a656"></a><!-- doxytag: member="mysqlpp::ConnectionPool::max_idle_time" ref="8a5ba414a5b02c48d64501c25b64a656" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int mysqlpp::ConnectionPool::max_idle_time           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the maximum number of seconds a connection is able to remain idle before it is dropped. 
<p>
Subclasses must override this as it encodes a policy issue, something that MySQL++ can't declare by fiat.<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>number</em>&nbsp;</td><td>of seconds before an idle connection is destroyed due to lack of use </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c51a7a63ce4d8825c3f7b05f4b8bfe68"></a><!-- doxytag: member="mysqlpp::ConnectionPool::release" ref="c51a7a63ce4d8825c3f7b05f4b8bfe68" args="(const Connection *pc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mysqlpp::ConnectionPool::release           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1Connection.html">Connection</a> *&nbsp;</td>
          <td class="paramname"> <em>pc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a connection to the pool. 
<p>
Marks the connection as no longer in use.<p>
The pool updates the last-used time of a connection only on release, on the assumption that it was used just prior. There's nothing forcing you to do it this way: your code is free to delay releasing idle connections as long as it likes. You want to avoid this because it will make the pool perform poorly; if it doesn't know approximately how long a connection has really been idle, it can't make good judgements about when to remove it from the pool.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pc</em>&nbsp;</td><td>pointer to a <a class="el" href="classmysqlpp_1_1Connection.html">Connection</a> object to be returned to the pool and marked as unused. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ae75febe979da2d4a3335c46438f3d33"></a><!-- doxytag: member="mysqlpp::ConnectionPool::remove" ref="ae75febe979da2d4a3335c46438f3d33" args="(const Connection *pc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mysqlpp::ConnectionPool::remove           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmysqlpp_1_1Connection.html">Connection</a> *&nbsp;</td>
          <td class="paramname"> <em>pc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes the given connection from the pool. 
<p>
If you mean to simply return a connection to the pool after you're finished using it, call <a class="el" href="classmysqlpp_1_1ConnectionPool.html#c51a7a63ce4d8825c3f7b05f4b8bfe68">release()</a> instead. This method is primarily for error handling: you somehow have figured out that the connection is defective, so want it destroyed and removed from the pool. If you also want a different connection to retry your operation on, call <a class="el" href="classmysqlpp_1_1ConnectionPool.html#4f9844f2c57c9f51f1b5a2b8a996ee15">exchange()</a> instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pc</em>&nbsp;</td><td>pointer to a <a class="el" href="classmysqlpp_1_1Connection.html">Connection</a> object to be removed from the pool and destroyed </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ac4d50bb5c603efec4b8d7e0a3e8a164"></a><!-- doxytag: member="mysqlpp::ConnectionPool::safe_grab" ref="ac4d50bb5c603efec4b8d7e0a3e8a164" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmysqlpp_1_1Connection.html">Connection</a> * mysqlpp::ConnectionPool::safe_grab           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Grab a free connection from the pool, testing that it's connected before returning it. 
<p>
This is just a wrapper around <a class="el" href="classmysqlpp_1_1ConnectionPool.html#cbf56ee86ef66b3ebdf02adde5908776">grab()</a>, <a class="el" href="classmysqlpp_1_1Connection.html#c1dbc411f7ab1debbabe241561fe4091">Connection::ping()</a> and <a class="el" href="classmysqlpp_1_1ConnectionPool.html#c51a7a63ce4d8825c3f7b05f4b8bfe68">release()</a>, and is thus less efficient than <a class="el" href="classmysqlpp_1_1ConnectionPool.html#cbf56ee86ef66b3ebdf02adde5908776">grab()</a>. Use it only when it's possible for MySQL server connections to go away unexpectedly, such as when the DB server can be restarted out from under your application.<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>pointer to the connection </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="cpool_8h-source.html">cpool.h</a><li>cpool.cpp</ul>
<hr size="1"><address style="align: right;"><small>Generated on 10 Dec 2013 for MySQL++ by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
